// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Vscode = require("vscode");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var GCL$Guacamole = require("../GCL.bs.js");
var Error$Guacamole = require("../Error.bs.js");
var State$Guacamole = require("../State.bs.js");
var Editor$Guacamole = require("../Editor.bs.js");
var Response$Guacamole = require("../Response.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Event$AgdaModeVscode = require("agda-mode-vscode/lib/js/src/Util/Event.bs.js");
var Task__View$Guacamole = require("./Task__View.bs.js");
var Task__Command$Guacamole = require("./Task__Command.bs.js");
var Task__Response$Guacamole = require("./Task__Response.bs.js");

function runTask(task, state) {
  if (typeof task === "number") {
    if (task === /* Connect */0) {
      return $$Promise.map(State$Guacamole.connect(state), (function (e) {
                    if (!e.tag) {
                      return Task__Command$Guacamole.dispatch(/* Reload */2);
                    }
                    var match = Error$Guacamole.toString(e[0]);
                    return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                              /* Display */Caml_chrome_debugger.variant("Display", 3, [
                                  /* Error */Caml_chrome_debugger.variant("Error", 1, [match[0]]),
                                  /* Plain */Caml_chrome_debugger.variant("Plain", 1, [match[1]])
                                ]),
                              /* [] */0
                            ]);
                  }));
    }
    Belt_Array.forEach(state.decorations, Editor$Guacamole.Decoration.destroy);
    return $$Promise.resolved(/* [] */0);
  } else {
    switch (task.tag | 0) {
      case /* WithState */0 :
          return Curry._1(task[0], state);
      case /* DispatchCommand */1 :
          var command = task[0];
          console.log("[ dispatch command ]", command);
          return $$Promise.resolved(Task__Command$Guacamole.dispatch(command));
      case /* SendRequest */2 :
          console.log("[ send request ]");
          return $$Promise.map(State$Guacamole.sendRequest(state, task[0]), (function (error) {
                        if (!error.tag) {
                          return Task__Response$Guacamole.handle(error[0]);
                        }
                        var match = Error$Guacamole.toString(error[0]);
                        return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                                  /* Display */Caml_chrome_debugger.variant("Display", 3, [
                                      /* Error */Caml_chrome_debugger.variant("Error", 1, [match[0]]),
                                      /* Plain */Caml_chrome_debugger.variant("Plain", 1, [match[1]])
                                    ]),
                                  /* [] */0
                                ]);
                      }));
      case /* Display */3 :
          return $$Promise.map(State$Guacamole.display(state, task[0], task[1]), (function (param) {
                        return /* [] */0;
                      }));
      case /* ViewRequest */4 :
          return $$Promise.map(State$Guacamole.sendRequestToView(state, task[0]), (function (param) {
                        return /* [] */0;
                      }));
      case /* ViewResponse */5 :
          return $$Promise.resolved(Task__View$Guacamole.handle(state.editor, task[0]));
      case /* MarkError */6 :
          var range = Curry._3(Response$Guacamole.$$Error.Site.toRange, task[0], state.specifications, GCL$Guacamole.Loc.toRange);
          var decorations = Editor$Guacamole.Decoration.highlightBackground(state.editor, "inputValidation.errorBackground", [range]);
          state.decorations = state.decorations.concat([decorations]);
          return $$Promise.resolved(/* [] */0);
      case /* MarkSpec */7 :
          var spec = task[0];
          var range$1 = GCL$Guacamole.Loc.toRange(spec.loc);
          var startPoint = range$1.start;
          var endPoint = range$1.end;
          var startRange = new Vscode.Range(startPoint, startPoint.translate(0, 2));
          var endRange = new Vscode.Range(endPoint.translate(0, -2), endPoint);
          var trim = function (s) {
            if (s.length > 77) {
              return $$String.sub(s, 0, 73) + " ...";
            } else {
              return s;
            }
          };
          var preCondText = " " + trim(Curry._1(GCL$Guacamole.Syntax.Pred.toString, spec.pre));
          var postCondText = " " + trim(Curry._1(GCL$Guacamole.Syntax.Pred.toString, spec.post));
          var isQQ = preCondText === postCondText;
          var decorations$1 = [
            Editor$Guacamole.Decoration.overlayText(state.editor, "descriptionForeground", isQQ ? "" : preCondText, startRange),
            Editor$Guacamole.Decoration.overlayText(state.editor, "descriptionForeground", postCondText, endRange),
            Editor$Guacamole.Decoration.highlightBackground(state.editor, "editor.wordHighlightStrongBackground", [startRange]),
            Editor$Guacamole.Decoration.highlightBackground(state.editor, "editor.wordHighlightStrongBackground", [endRange])
          ];
          state.decorations = state.decorations.concat(decorations$1);
          return $$Promise.resolved(/* [] */0);
      case /* DigHole */8 :
          var range$2 = Curry._3(Response$Guacamole.$$Error.Site.toRange, task[0], state.specifications, GCL$Guacamole.Loc.toRange);
          var editor = state.editor;
          var indent = " ".repeat(range$2.start.character);
          var holeText = "{!\n" + (indent + ("\n" + (indent + "!}")));
          var holeRange = new Vscode.Range(range$2.start, range$2.start.translate(0, 1));
          return $$Promise.map(Editor$Guacamole.$$Text.replace(editor.document, holeRange, holeText), (function (param) {
                        var selectionRange = new Vscode.Range(range$2.start.translate(1, 0), range$2.start.translate(1, 0));
                        Editor$Guacamole.$$Text.select(editor, selectionRange);
                        return /* [] */0;
                      }));
      
    }
  }
}

function addTask(self, task) {
  return Curry._1(self.taskEmitter.emit, task);
}

function make(state) {
  var queue = [];
  var taskEmitter = Event$AgdaModeVscode.make(undefined);
  var statusEmitter = Event$AgdaModeVscode.make(undefined);
  var self = {
    taskEmitter: taskEmitter,
    status: /* Idle */1,
    statusEmitter: statusEmitter
  };
  var runTasksInQueue = function (param) {
    var nextTask = queue.shift();
    if (nextTask !== undefined) {
      return $$Promise.get(runTask(nextTask, state), (function (newTasks) {
                    Belt_List.forEach(newTasks, (function (param) {
                            return Curry._1(self.taskEmitter.emit, param);
                          }));
                    return runTasksInQueue(undefined);
                  }));
    } else {
      self.status = /* Idle */1;
      return Curry._1(self.statusEmitter.emit, /* Idle */1);
    }
  };
  Curry._1(taskEmitter.on, (function (task) {
          queue.push(task);
          if (self.status === /* Idle */1) {
            self.status = /* Busy */0;
            Curry._1(self.statusEmitter.emit, /* Busy */0);
            return runTasksInQueue(undefined);
          }
          
        }));
  return self;
}

function destroy(self) {
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  var destroy$prime = function (param) {
    Curry._1(self.statusEmitter.destroy, undefined);
    Curry._1(self.taskEmitter.destroy, undefined);
    return Curry._1(resolve, undefined);
  };
  var match$1 = self.status;
  if (match$1) {
    destroy$prime(undefined);
  } else {
    Curry._1(self.statusEmitter.on, (function (param) {
            if (param) {
              return destroy$prime(undefined);
            }
            
          }));
  }
  return match[0];
}

var TaskCommand;

var TaskResponse;

var TaskView;

exports.TaskCommand = TaskCommand;
exports.TaskResponse = TaskResponse;
exports.TaskView = TaskView;
exports.runTask = runTask;
exports.addTask = addTask;
exports.make = make;
exports.destroy = destroy;
/* vscode Not a pure module */
