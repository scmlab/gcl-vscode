// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var GCL$Guacamole = require("../GCL.bs.js");
var Caml_splice_call = require("bs-platform/lib/js/caml_splice_call.js");
var Response$Guacamole = require("../Response.bs.js");

function handle(site, param) {
  switch (param) {
    case /* MissingAssertion */0 :
        return {
                hd: {
                  TAG: 6,
                  _0: site,
                  [Symbol.for("name")]: "MarkError"
                },
                tl: {
                  hd: {
                    TAG: 3,
                    _0: {
                      TAG: 1,
                      _0: "Assertion Missing",
                      [Symbol.for("name")]: "Error"
                    },
                    _1: {
                      TAG: 1,
                      _0: "Assertion before the DO construct is missing",
                      [Symbol.for("name")]: "Plain"
                    },
                    [Symbol.for("name")]: "Display"
                  },
                  tl: /* [] */0
                }
              };
    case /* MissingBound */1 :
        return {
                hd: {
                  TAG: 6,
                  _0: site,
                  [Symbol.for("name")]: "MarkError"
                },
                tl: {
                  hd: {
                    TAG: 3,
                    _0: {
                      TAG: 1,
                      _0: "Bound Missing",
                      [Symbol.for("name")]: "Error"
                    },
                    _1: {
                      TAG: 1,
                      _0: "Bound missing at the end of the assertion before the DO construct \" , bnd : ... }\"",
                      [Symbol.for("name")]: "Plain"
                    },
                    [Symbol.for("name")]: "Display"
                  },
                  tl: /* [] */0
                }
              };
    case /* ExcessBound */2 :
        return {
                hd: {
                  TAG: 6,
                  _0: site,
                  [Symbol.for("name")]: "MarkError"
                },
                tl: {
                  hd: {
                    TAG: 3,
                    _0: {
                      TAG: 1,
                      _0: "Excess Bound",
                      [Symbol.for("name")]: "Error"
                    },
                    _1: {
                      TAG: 1,
                      _0: "Unnecessary bound annotation at this assertion",
                      [Symbol.for("name")]: "Plain"
                    },
                    [Symbol.for("name")]: "Display"
                  },
                  tl: /* [] */0
                }
              };
    case /* MissingPostcondition */3 :
        return {
                hd: {
                  TAG: 6,
                  _0: site,
                  [Symbol.for("name")]: "MarkError"
                },
                tl: {
                  hd: {
                    TAG: 3,
                    _0: {
                      TAG: 1,
                      _0: "Postcondition Missing",
                      [Symbol.for("name")]: "Error"
                    },
                    _1: {
                      TAG: 1,
                      _0: "The last statement of the program should be an assertion",
                      [Symbol.for("name")]: "Plain"
                    },
                    [Symbol.for("name")]: "Display"
                  },
                  tl: /* [] */0
                }
              };
    case /* DigHole */4 :
        return {
                hd: {
                  TAG: 8,
                  _0: site,
                  [Symbol.for("name")]: "DigHole"
                },
                tl: {
                  hd: {
                    TAG: 1,
                    _0: /* Reload */2,
                    [Symbol.for("name")]: "DispatchCommand"
                  },
                  tl: /* [] */0
                }
              };
    
  }
}

var StructError = {
  handle: handle
};

function handle$1(site, param) {
  switch (param) {
    case /* MissingLoopInvariant */0 :
        return {
                hd: {
                  TAG: 6,
                  _0: site,
                  [Symbol.for("name")]: "MarkError"
                },
                tl: {
                  hd: {
                    TAG: 3,
                    _0: {
                      TAG: 1,
                      _0: "Loop Invariant Missing",
                      [Symbol.for("name")]: "Error"
                    },
                    _1: {
                      TAG: 1,
                      _0: "Loop invariant before the DO construct is missing",
                      [Symbol.for("name")]: "Plain"
                    },
                    [Symbol.for("name")]: "Display"
                  },
                  tl: /* [] */0
                }
              };
    case /* MissingBound */1 :
        return {
                hd: {
                  TAG: 6,
                  _0: site,
                  [Symbol.for("name")]: "MarkError"
                },
                tl: {
                  hd: {
                    TAG: 3,
                    _0: {
                      TAG: 1,
                      _0: "Bound Missing",
                      [Symbol.for("name")]: "Error"
                    },
                    _1: {
                      TAG: 1,
                      _0: "Bound missing at the end of the assertion before the DO construct \" , bnd : ... }\"",
                      [Symbol.for("name")]: "Plain"
                    },
                    [Symbol.for("name")]: "Display"
                  },
                  tl: /* [] */0
                }
              };
    case /* MissingPrecondition */2 :
        return {
                hd: {
                  TAG: 6,
                  _0: site,
                  [Symbol.for("name")]: "MarkError"
                },
                tl: {
                  hd: {
                    TAG: 3,
                    _0: {
                      TAG: 1,
                      _0: "Precondition Missing",
                      [Symbol.for("name")]: "Error"
                    },
                    _1: {
                      TAG: 1,
                      _0: "The first statement of the program should be an assertion",
                      [Symbol.for("name")]: "Plain"
                    },
                    [Symbol.for("name")]: "Display"
                  },
                  tl: /* [] */0
                }
              };
    case /* MissingPostcondition */3 :
        return {
                hd: {
                  TAG: 6,
                  _0: site,
                  [Symbol.for("name")]: "MarkError"
                },
                tl: {
                  hd: {
                    TAG: 3,
                    _0: {
                      TAG: 1,
                      _0: "Postcondition Missing",
                      [Symbol.for("name")]: "Error"
                    },
                    _1: {
                      TAG: 1,
                      _0: "The last statement of the program should be an assertion",
                      [Symbol.for("name")]: "Plain"
                    },
                    [Symbol.for("name")]: "Display"
                  },
                  tl: /* [] */0
                }
              };
    case /* PreconditionUnknown */4 :
        return {
                hd: {
                  TAG: 6,
                  _0: site,
                  [Symbol.for("name")]: "MarkError"
                },
                tl: {
                  hd: {
                    TAG: 3,
                    _0: {
                      TAG: 1,
                      _0: "Precondition Unknown",
                      [Symbol.for("name")]: "Error"
                    },
                    _1: {
                      TAG: 1,
                      _0: "",
                      [Symbol.for("name")]: "Plain"
                    },
                    [Symbol.for("name")]: "Display"
                  },
                  tl: /* [] */0
                }
              };
    case /* DigHole */5 :
        return {
                hd: {
                  TAG: 8,
                  _0: site,
                  [Symbol.for("name")]: "DigHole"
                },
                tl: {
                  hd: {
                    TAG: 1,
                    _0: /* Reload */2,
                    [Symbol.for("name")]: "DispatchCommand"
                  },
                  tl: /* [] */0
                }
              };
    
  }
}

var StructError2 = {
  handle: handle$1
};

function handle$2(error) {
  var kind = error._1;
  var site = error._0;
  if (typeof kind === "number") {
    if (kind === /* LexicalError */0) {
      return {
              hd: {
                TAG: 6,
                _0: site,
                [Symbol.for("name")]: "MarkError"
              },
              tl: {
                hd: {
                  TAG: 3,
                  _0: {
                    TAG: 1,
                    _0: "Lexical Error",
                    [Symbol.for("name")]: "Error"
                  },
                  _1: {
                    TAG: 1,
                    _0: Curry._1(Response$Guacamole.$$Error.Site.toString, site),
                    [Symbol.for("name")]: "Plain"
                  },
                  [Symbol.for("name")]: "Display"
                },
                tl: /* [] */0
              }
            };
    } else {
      return {
              hd: {
                TAG: 6,
                _0: site,
                [Symbol.for("name")]: "MarkError"
              },
              tl: {
                hd: {
                  TAG: 3,
                  _0: {
                    TAG: 1,
                    _0: "Not Loaded",
                    [Symbol.for("name")]: "Error"
                  },
                  _1: {
                    TAG: 1,
                    _0: "Please load the file first",
                    [Symbol.for("name")]: "Plain"
                  },
                  [Symbol.for("name")]: "Display"
                },
                tl: /* [] */0
              }
            };
    }
  }
  switch (kind.TAG | 0) {
    case /* SyntacticError */0 :
        return {
                hd: {
                  TAG: 6,
                  _0: site,
                  [Symbol.for("name")]: "MarkError"
                },
                tl: {
                  hd: {
                    TAG: 3,
                    _0: {
                      TAG: 1,
                      _0: "Parse Error",
                      [Symbol.for("name")]: "Error"
                    },
                    _1: {
                      TAG: 1,
                      _0: Caml_splice_call.spliceObjApply("\n", "concat", [kind._0]),
                      [Symbol.for("name")]: "Plain"
                    },
                    [Symbol.for("name")]: "Display"
                  },
                  tl: /* [] */0
                }
              };
    case /* StructError */1 :
        return handle(site, kind._0);
    case /* StructError2 */2 :
        return handle$1(site, kind._0);
    case /* TypeError */3 :
        var name = kind._0;
        switch (name.TAG | 0) {
          case /* NotInScope */0 :
              return {
                      hd: {
                        TAG: 6,
                        _0: site,
                        [Symbol.for("name")]: "MarkError"
                      },
                      tl: {
                        hd: {
                          TAG: 3,
                          _0: {
                            TAG: 1,
                            _0: "Type Error",
                            [Symbol.for("name")]: "Error"
                          },
                          _1: {
                            TAG: 1,
                            _0: "The definition " + (name._0 + " is not in scope"),
                            [Symbol.for("name")]: "Plain"
                          },
                          [Symbol.for("name")]: "Display"
                        },
                        tl: /* [] */0
                      }
                    };
          case /* UnifyFailed */1 :
              return {
                      hd: {
                        TAG: 6,
                        _0: site,
                        [Symbol.for("name")]: "MarkError"
                      },
                      tl: {
                        hd: {
                          TAG: 3,
                          _0: {
                            TAG: 1,
                            _0: "Type Error",
                            [Symbol.for("name")]: "Error"
                          },
                          _1: {
                            TAG: 1,
                            _0: "Cannot unify: " + (Curry._1(GCL$Guacamole.Syntax.Type.toString, name._0) + ("\nwith        : " + Curry._1(GCL$Guacamole.Syntax.Type.toString, name._1))),
                            [Symbol.for("name")]: "Plain"
                          },
                          [Symbol.for("name")]: "Display"
                        },
                        tl: /* [] */0
                      }
                    };
          case /* RecursiveType */2 :
              return {
                      hd: {
                        TAG: 6,
                        _0: site,
                        [Symbol.for("name")]: "MarkError"
                      },
                      tl: {
                        hd: {
                          TAG: 3,
                          _0: {
                            TAG: 1,
                            _0: "Type Error",
                            [Symbol.for("name")]: "Error"
                          },
                          _1: {
                            TAG: 1,
                            _0: "Recursive type variable: " + (Curry._1(GCL$Guacamole.Syntax.Type.toString, {
                                    TAG: 3,
                                    _0: name._0,
                                    [Symbol.for("name")]: "Var"
                                  }) + ("\nin type             : " + Curry._1(GCL$Guacamole.Syntax.Type.toString, name._1))),
                            [Symbol.for("name")]: "Plain"
                          },
                          [Symbol.for("name")]: "Display"
                        },
                        tl: /* [] */0
                      }
                    };
          case /* NotFunction */3 :
              return {
                      hd: {
                        TAG: 6,
                        _0: site,
                        [Symbol.for("name")]: "MarkError"
                      },
                      tl: {
                        hd: {
                          TAG: 3,
                          _0: {
                            TAG: 1,
                            _0: "Type Error",
                            [Symbol.for("name")]: "Error"
                          },
                          _1: {
                            TAG: 1,
                            _0: "The type " + (Curry._1(GCL$Guacamole.Syntax.Type.toString, name._0) + " is not a function type"),
                            [Symbol.for("name")]: "Plain"
                          },
                          [Symbol.for("name")]: "Display"
                        },
                        tl: /* [] */0
                      }
                    };
          
        }
    case /* CannotDecodeRequest */4 :
        return {
                hd: {
                  TAG: 6,
                  _0: site,
                  [Symbol.for("name")]: "MarkError"
                },
                tl: {
                  hd: {
                    TAG: 3,
                    _0: {
                      TAG: 1,
                      _0: "Cannot Decode Request",
                      [Symbol.for("name")]: "Error"
                    },
                    _1: {
                      TAG: 1,
                      _0: kind._0,
                      [Symbol.for("name")]: "Plain"
                    },
                    [Symbol.for("name")]: "Display"
                  },
                  tl: /* [] */0
                }
              };
    case /* CannotReadFile */5 :
        return {
                hd: {
                  TAG: 6,
                  _0: site,
                  [Symbol.for("name")]: "MarkError"
                },
                tl: {
                  hd: {
                    TAG: 3,
                    _0: {
                      TAG: 1,
                      _0: "Cannot Read File",
                      [Symbol.for("name")]: "Error"
                    },
                    _1: {
                      TAG: 1,
                      _0: "Cannot read file of path: " + kind._0,
                      [Symbol.for("name")]: "Plain"
                    },
                    [Symbol.for("name")]: "Display"
                  },
                  tl: /* [] */0
                }
              };
    
  }
}

exports.StructError = StructError;
exports.StructError2 = StructError2;
exports.handle = handle$2;
/* GCL-Guacamole Not a pure module */
