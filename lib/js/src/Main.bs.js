// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var VSCode = require("bs-vscode/lib/js/src/VSCode.bs.js");
var Vscode = require("vscode");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var GCL$Guacamole = require("./GCL.bs.js");
var Util$Guacamole = require("./Util/Util.bs.js");
var View$Guacamole = require("./View.bs.js");
var State$Guacamole = require("./State.bs.js");
var Registry$Guacamole = require("./Registry.bs.js");
var Connection$Guacamole = require("./Connection.bs.js");

var partial_arg = /\.gcl$/i;

function isGCL(param) {
  return partial_arg.test(param);
}

var previouslyActivatedState = {
  contents: undefined
};

function handleResponse(response) {
  switch (response.TAG | 0) {
    case /* Res */0 :
        var kinds = response._1;
        return Belt_Option.mapWithDefault(Registry$Guacamole.get(response._0), $$Promise.resolved(undefined), (function (state) {
                      return $$Promise.map(Util$Guacamole.$$Promise.oneByOne(Belt_Array.map(kinds, (function (param) {
                                            return State$Guacamole.handleResponseKind(state, param);
                                          }))), (function (param) {
                                    
                                  }));
                    }));
    case /* CannotDecodeResponse */1 :
        return State$Guacamole.displayErrorMessages([[
                      "Client Internal Error",
                      "Cannot decode response from the server\n" + response._0 + "\n" + JSON.stringify(response._1)
                    ]]);
    case /* CannotDecodeRequest */2 :
        return State$Guacamole.displayErrorMessages([[
                      "Server Internal Error",
                      "Cannot decode request from the client\n" + response._0
                    ]]);
    case /* CannotSendRequest */3 :
        return State$Guacamole.displayErrorMessages([[
                      "Client Internal Error",
                      "Cannot send request to the server\n" + response._0
                    ]]);
    
  }
}

function sendLSPRequest(state, kind) {
  return $$Promise.flatMap(State$Guacamole.sendLSPRequest(state, kind), (function (result) {
                if (result.TAG === /* Ok */0) {
                  return handleResponse(result._0);
                } else {
                  return State$Guacamole.displayErrorMessage(Connection$Guacamole.$$Error.toString(result._0));
                }
              }));
}

function getState(param) {
  return previouslyActivatedState.contents;
}

function handleViewResponse(response) {
  return Belt_Option.forEach(previouslyActivatedState.contents, (function (state) {
                if (typeof response === "number") {
                  switch (response) {
                    case /* ExportProofObligations */0 :
                        sendLSPRequest(state, /* ExportProofObligations */1);
                        return ;
                    case /* Initialized */1 :
                    case /* Destroyed */2 :
                        return ;
                    
                  }
                } else if (response.TAG === /* Link */0) {
                  var loc = response._0;
                  switch (loc.TAG | 0) {
                    case /* MouseOver */0 :
                        var loc$1 = loc._0;
                        var key = GCL$Guacamole.Loc.toString(loc$1);
                        var range = GCL$Guacamole.Loc.toRange(loc$1);
                        return State$Guacamole.Decoration.addBackground(state, key, range, "statusBar.debuggingBackground");
                    case /* MouseOut */1 :
                    case /* MouseClick */2 :
                        return State$Guacamole.Decoration.remove(GCL$Guacamole.Loc.toString(loc._0));
                    
                  }
                } else {
                  State$Guacamole.Decoration.removeAll(undefined);
                  sendLSPRequest(state, {
                        TAG: 2,
                        _0: response._0,
                        _1: response._1,
                        _2: response._2,
                        [Symbol.for("name")]: "Substitute"
                      });
                  return ;
                }
              }));
}

function isGCL$1(editor) {
  return /\.gcl$/i.test(editor.document.fileName);
}

function isGCL$prime($$document) {
  return /\.gcl$/i.test($$document.fileName);
}

function onOpenEditor(callback) {
  var f = function (editor) {
    if (isGCL$1(editor)) {
      return Curry._1(callback, editor);
    }
    
  };
  Belt_Option.forEach(Vscode.window.activeTextEditor, f);
  return Vscode.window.onDidChangeActiveTextEditor(function (next) {
              return Belt_Option.forEach(next, f);
            });
}

function onCloseEditor(callback) {
  return Vscode.workspace.onDidCloseTextDocument(function ($$document) {
              if (isGCL$prime($$document)) {
                return Curry._1(callback, $$document);
              }
              
            });
}

function onActivateExtension(callback) {
  return onOpenEditor(function (param) {
              var visibleCount = Belt_Array.keep(Vscode.window.visibleTextEditors, isGCL$1).length;
              var shouldAcitvateView = visibleCount > 0 && !View$Guacamole.isActivated(undefined);
              if (shouldAcitvateView) {
                return Curry._1(callback, undefined);
              }
              
            });
}

function onDeactivateExtension(callback) {
  return onCloseEditor(function (param) {
              var openedCount = Registry$Guacamole.size(undefined);
              var shouldDeacitvateView = openedCount === 0 && View$Guacamole.isActivated(undefined);
              if (shouldDeacitvateView) {
                return Curry._1(callback, undefined);
              }
              
            });
}

function onChangeCursorPosition(callback) {
  return Vscode.window.onDidChangeTextEditorSelection(callback);
}

var Events = {
  isGCL: isGCL$1,
  isGCL$prime: isGCL$prime,
  onOpenEditor: onOpenEditor,
  onCloseEditor: onCloseEditor,
  onActivateExtension: onActivateExtension,
  onDeactivateExtension: onDeactivateExtension,
  onChangeCursorPosition: onChangeCursorPosition
};

function activate(context) {
  var devMode = VSCode.ExtensionContext.extensionMode(context) === /* Development */1;
  var subscribe = function (x) {
    context.subscriptions.push(x);
    
  };
  subscribe(Connection$Guacamole.onResponse(function (result) {
            if (result.TAG === /* Ok */0) {
              handleResponse(result._0);
              return ;
            }
            var message = Connection$Guacamole.$$Error.toString(result._0);
            State$Guacamole.displayErrorMessage(message);
            
          }));
  subscribe(Connection$Guacamole.onError(function (error) {
            var message = Connection$Guacamole.$$Error.toString(error);
            State$Guacamole.displayErrorMessage(message);
            
          }));
  subscribe(onOpenEditor(function (editor) {
            var filePath = editor.document.fileName;
            var state = Registry$Guacamole.get(filePath);
            var state$1;
            if (state !== undefined) {
              state.editor = editor;
              state.document = editor.document;
              state.filePath = filePath;
              state$1 = state;
            } else {
              var state$2 = State$Guacamole.make(devMode, editor);
              Registry$Guacamole.add(filePath, state$2);
              state$1 = state$2;
            }
            previouslyActivatedState.contents = state$1;
            sendLSPRequest(state$1, /* Load */0);
            
          }));
  subscribe(onCloseEditor(function ($$document) {
            return Registry$Guacamole.destroy($$document.fileName);
          }));
  subscribe(onActivateExtension(function (param) {
            var extensionPath = context.extensionPath;
            return $$Promise.get(View$Guacamole.activate(extensionPath, devMode), (function (_viewActivationResult) {
                          return $$Promise.get(Connection$Guacamole.make(devMode), (function (result) {
                                        if (result.TAG === /* Ok */0) {
                                          State$Guacamole.updateConnection(result._0);
                                          return ;
                                        }
                                        console.log(result._0);
                                        
                                      }));
                        }));
          }));
  subscribe(onDeactivateExtension(function (param) {
            View$Guacamole.deactivate(undefined);
            previouslyActivatedState.contents = undefined;
            Connection$Guacamole.destroy(undefined);
            
          }));
  subscribe(Vscode.window.onDidChangeTextEditorSelection(function ($$event) {
            var selections = $$event.selections;
            var editor = $$event.textEditor;
            var filePath = editor.document.fileName;
            var match = VSCode.TextEditorSelectionChangeEvent.kind($$event);
            var shouldTrigger = match !== undefined ? match < 2 : false;
            if (shouldTrigger) {
              return Belt_Option.forEach(Registry$Guacamole.get(filePath), (function (state) {
                            return Belt_Option.forEach(Belt_Array.get(selections, 0), (function (selection) {
                                          var start = state.document.offsetAt(selection.start);
                                          var end_ = state.document.offsetAt(selection.end);
                                          sendLSPRequest(state, {
                                                TAG: 0,
                                                _0: start,
                                                _1: end_,
                                                [Symbol.for("name")]: "Inspect"
                                              });
                                          
                                        }));
                          }));
            }
            
          }));
  subscribe(View$Guacamole.on(handleViewResponse));
  subscribe(Vscode.commands.registerCommand("guacamole.refine", (function (param) {
              return Belt_Option.mapWithDefault(previouslyActivatedState.contents, $$Promise.resolved(undefined), (function (state) {
                            return Belt_Option.mapWithDefault(State$Guacamole.Spec.fromCursorPosition(state), $$Promise.resolved(undefined), (function (spec) {
                                          var payload = State$Guacamole.Spec.getPayload(state.document, spec);
                                          var payload$1 = payload.join("\n");
                                          return sendLSPRequest(state, {
                                                      TAG: 1,
                                                      _0: spec.id,
                                                      _1: payload$1,
                                                      [Symbol.for("name")]: "Refine"
                                                    });
                                        }));
                          }));
            })));
  return subscribe(Vscode.commands.registerCommand("guacamole.debug", (function (param) {
                    return Belt_Option.mapWithDefault(previouslyActivatedState.contents, $$Promise.resolved(undefined), (function (state) {
                                  return sendLSPRequest(state, /* Debug */2);
                                }));
                  })));
}

function deactivate(param) {
  
}

exports.isGCL = isGCL;
exports.previouslyActivatedState = previouslyActivatedState;
exports.handleResponse = handleResponse;
exports.sendLSPRequest = sendLSPRequest;
exports.getState = getState;
exports.handleViewResponse = handleViewResponse;
exports.Events = Events;
exports.activate = activate;
exports.deactivate = deactivate;
/* VSCode Not a pure module */
