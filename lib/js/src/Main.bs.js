// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var VSCode = require("bs-vscode/lib/js/src/VSCode.bs.js");
var Vscode = require("vscode");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var LSP$Guacamole = require("./LSP.bs.js");
var Util$Guacamole = require("./Util/Util.bs.js");
var View$Guacamole = require("./View.bs.js");
var State$Guacamole = require("./State.bs.js");
var Request$Guacamole = require("./Request.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var Registry$Guacamole = require("./Registry.bs.js");
var Response$Guacamole = require("./Response.bs.js");
var VscodeLanguageclient = require("vscode-languageclient");

var partial_arg = /\.gcl$/i;

function isGCL(param) {
  return partial_arg.test(param);
}

function handleResponse(response) {
  switch (response.TAG | 0) {
    case /* Res */0 :
        var kinds = response._1;
        return Belt_Option.mapWithDefault(Registry$Guacamole.get(response._0), $$Promise.resolved(undefined), (function (state) {
                      return $$Promise.map(Util$Guacamole.$$Promise.oneByOne(Belt_Array.map(kinds, (function (param) {
                                            return State$Guacamole.handleResponseKind(state, param);
                                          }))), (function (param) {
                                    
                                  }));
                    }));
    case /* CannotDecodeResponse */1 :
        console.error("Client Internal Error\nCannot decode response from the server\n" + response._0, response._1);
        return $$Promise.resolved(undefined);
    case /* CannotDecodeRequest */2 :
        console.error("Server Internal Error\nCannot decode request from the client\n" + response._0);
        return $$Promise.resolved(undefined);
    case /* CannotSendRequest */3 :
        console.error("Client Internal Error\nCannot send request to the server\n" + response._0);
        return $$Promise.resolved(undefined);
    
  }
}

function make(param) {
  var serverOptions = LSP$Guacamole.ServerOptions.makeCommand("gcl");
  var documentSelector = [VSCode.StringOr.others({
          language: "guacamole",
          pattern: undefined,
          scheme: "file"
        })];
  var synchronize = Vscode.workspace.createFileSystemWatcher('**/.clientrc', false, false, false);
  var clientOptions = LSP$Guacamole.LanguageClientOptions.make(documentSelector, synchronize);
  return new VscodeLanguageclient.LanguageClient("guacamoleLanguageServer", "Guacamole Language Server", serverOptions, clientOptions);
}

var handle = {
  client: make(undefined),
  subscription: undefined
};

function start(param) {
  if (Belt_Option.isNone(handle.subscription)) {
    handle.subscription = Caml_option.some(handle.client.start());
    return ;
  }
  
}

function stop(param) {
  var subscription$prime = handle.subscription;
  if (subscription$prime === undefined) {
    return $$Promise.resolved(undefined);
  }
  var subscription$prime$1 = Caml_option.valFromOption(subscription$prime);
  return $$Promise.tap(handle.client.stop(), (function (param) {
                handle.subscription = undefined;
                return subscription$prime$1.dispose();
              }));
}

function decodeResponse(json) {
  try {
    return Response$Guacamole.decode(json);
  }
  catch (raw_msg){
    var msg = Caml_js_exceptions.internalToOCamlException(raw_msg);
    if (msg.RE_EXN_ID === Json_decode.DecodeError) {
      return {
              TAG: 1,
              _0: msg._1,
              _1: json,
              [Symbol.for("name")]: "CannotDecodeResponse"
            };
    }
    throw msg;
  }
}

function on(handler) {
  return $$Promise.getOk($$Promise.Js.toResult(handle.client.onReady()), (function (param) {
                handle.client.onNotification("guacamole", (function (json) {
                        return Curry._1(handler, decodeResponse(json));
                      }));
                
              }));
}

function send(request) {
  start(undefined);
  return $$Promise.map($$Promise.flatMapOk($$Promise.Js.toResult(handle.client.onReady()), (function (param) {
                    var value = Request$Guacamole.encode(request);
                    return $$Promise.Js.toResult(handle.client.sendRequest("guacamole", value));
                  })), (function (x) {
                if (x.TAG) {
                  return {
                          TAG: 3,
                          _0: Response$Guacamole.$$Error.fromJsError(x._0),
                          [Symbol.for("name")]: "CannotSendRequest"
                        };
                } else {
                  return decodeResponse(x._0);
                }
              }));
}

var Client = {
  start: start,
  stop: stop,
  on: on,
  send: send
};

function onSelect($$event) {
  var selections = $$event.selections;
  var editor = $$event.textEditor;
  var filePath = editor.document.fileName;
  var match = VSCode.TextEditorSelectionChangeEvent.kind($$event);
  var shouldTrigger = match !== undefined ? match < 2 : false;
  if (shouldTrigger) {
    return Belt_Option.forEach(Registry$Guacamole.get(filePath), (function (state) {
                  return Belt_Option.forEach(Belt_Array.get(selections, 0), (function (selection) {
                                var start = state.document.offsetAt(selection.start);
                                var end_ = state.document.offsetAt(selection.end);
                                $$Promise.flatMap(send({
                                          _0: state.filePath,
                                          _1: {
                                            TAG: 0,
                                            _0: start,
                                            _1: end_,
                                            [Symbol.for("name")]: "Inspect"
                                          },
                                          [Symbol.for("name")]: "Req"
                                        }), handleResponse);
                                
                              }));
                }));
  }
  
}

function onActivateExtension(callback) {
  var visibleCount = Belt_Array.keep(Vscode.window.visibleTextEditors, (function (editor) {
          return isGCL(editor.document.fileName);
        })).length;
  var shouldAcitvateView = visibleCount > 0 && !View$Guacamole.isActivated(undefined);
  if (shouldAcitvateView) {
    return Curry._1(callback, undefined);
  }
  
}

function onDeactivateExtension(callback) {
  var openedCount = Registry$Guacamole.size(undefined);
  var shouldDeacitvateView = openedCount === 0 && View$Guacamole.isActivated(undefined);
  if (shouldDeacitvateView) {
    return Curry._1(callback, undefined);
  }
  
}

function onOpenEditor(context, editor) {
  var filePath = editor.document.fileName;
  if (!isGCL(filePath)) {
    return ;
  }
  onActivateExtension(function (param) {
        View$Guacamole.activate(context.extensionPath);
        return start(undefined);
      });
  var state = Registry$Guacamole.get(filePath);
  var state$1;
  if (state !== undefined) {
    state.editor = editor;
    state.document = editor.document;
    state.filePath = filePath;
    state$1 = state;
  } else {
    var state$2 = State$Guacamole.make(editor, View$Guacamole.send, View$Guacamole.on, send);
    Registry$Guacamole.add(filePath, state$2);
    state$1 = state$2;
  }
  $$Promise.flatMap(send({
            _0: state$1.filePath,
            _1: /* Load */0,
            [Symbol.for("name")]: "Req"
          }), handleResponse);
  
}

function onCloseEditor(doc) {
  var filePath = doc.fileName;
  if (isGCL(filePath)) {
    Registry$Guacamole.destroy(filePath);
    return onDeactivateExtension(function (param) {
                View$Guacamole.deactivate(undefined);
                stop(undefined);
                
              });
  }
  
}

function onNotification(response) {
  handleResponse(response);
  
}

var Handler = {
  onSelect: onSelect,
  onActivateExtension: onActivateExtension,
  onDeactivateExtension: onDeactivateExtension,
  onOpenEditor: onOpenEditor,
  onCloseEditor: onCloseEditor,
  onNotification: onNotification
};

function activate(context) {
  var subscribe = function (x) {
    context.subscriptions.push(x);
    
  };
  Belt_Option.forEach(Vscode.window.activeTextEditor, (function (param) {
          return onOpenEditor(context, param);
        }));
  subscribe(Vscode.window.onDidChangeActiveTextEditor(function (next) {
            return Belt_Option.forEach(next, (function (param) {
                          return onOpenEditor(context, param);
                        }));
          }));
  subscribe(Vscode.workspace.onDidCloseTextDocument(onCloseEditor));
  subscribe(Vscode.window.onDidChangeTextEditorSelection(onSelect));
  return on(onNotification);
}

function deactivate(param) {
  
}

exports.isGCL = isGCL;
exports.handleResponse = handleResponse;
exports.Client = Client;
exports.Handler = Handler;
exports.activate = activate;
exports.deactivate = deactivate;
/* handle Not a pure module */
