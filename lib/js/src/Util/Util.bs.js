// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var React = require("react");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var Caml_splice_call = require("rescript/lib/js/caml_splice_call.js");
var CompareVersions = require("compare-versions");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

function oneByOne$p(xs) {
  if (!xs) {
    return $$Promise.resolved(/* [] */0);
  }
  var xs$1 = xs.tl;
  return $$Promise.flatMap(xs.hd, (function (x$p) {
                return $$Promise.map(oneByOne$p(xs$1), (function (xs$p) {
                              return {
                                      hd: x$p,
                                      tl: xs$p
                                    };
                            }));
              }));
}

function oneByOne(xs) {
  return $$Promise.map(oneByOne$p(Belt_List.fromArray(xs)), Belt_List.toArray);
}

var $$Promise$1 = {
  oneByOne$p: oneByOne$p,
  oneByOne: oneByOne
};

function sum(decoder) {
  return function (param) {
    return Json_decode.andThen((function (tag) {
                  var d = Curry._1(decoder, tag);
                  if (d.TAG !== /* Contents */0) {
                    return d._0;
                  }
                  var d$1 = d._0;
                  return function (param) {
                    return Json_decode.field("contents", d$1, param);
                  };
                }), (function (param) {
                  return Json_decode.field("tag", Json_decode.string, param);
                }), param);
  };
}

function maybe(decoder) {
  return sum(function (x) {
              if (x === "Just") {
                return {
                        TAG: /* Contents */0,
                        _0: (function (json) {
                            return Caml_option.some(Curry._1(decoder, json));
                          })
                      };
              } else {
                return {
                        TAG: /* TagOnly */1,
                        _0: (function (param) {
                            
                          })
                      };
              }
            });
}

function tuple5(decodeA, decodeB, decodeC, decodeD, decodeE, json) {
  if (Array.isArray(json)) {
    var length = json.length;
    if (length === 5) {
      try {
        return [
                Curry._1(decodeA, json[0]),
                Curry._1(decodeB, json[1]),
                Curry._1(decodeC, json[2]),
                Curry._1(decodeD, json[3]),
                Curry._1(decodeE, json[4])
              ];
      }
      catch (raw_msg){
        var msg = Caml_js_exceptions.internalToOCamlException(raw_msg);
        if (msg.RE_EXN_ID === Json_decode.DecodeError) {
          throw {
                RE_EXN_ID: Json_decode.DecodeError,
                _1: msg._1 + "\n\tin tuple5",
                Error: new Error()
              };
        }
        throw msg;
      }
    } else {
      throw {
            RE_EXN_ID: Json_decode.DecodeError,
            _1: "Expected array of length 5, got array of length " + length,
            Error: new Error()
          };
    }
  } else {
    throw {
          RE_EXN_ID: Json_decode.DecodeError,
          _1: "Expected array, got " + JSON.stringify(json),
          Error: new Error()
        };
  }
}

function tuple6(decodeA, decodeB, decodeC, decodeD, decodeE, decodeF, json) {
  if (Array.isArray(json)) {
    var length = json.length;
    if (length === 6) {
      try {
        return [
                Curry._1(decodeA, json[0]),
                Curry._1(decodeB, json[1]),
                Curry._1(decodeC, json[2]),
                Curry._1(decodeD, json[3]),
                Curry._1(decodeE, json[4]),
                Curry._1(decodeF, json[5])
              ];
      }
      catch (raw_msg){
        var msg = Caml_js_exceptions.internalToOCamlException(raw_msg);
        if (msg.RE_EXN_ID === Json_decode.DecodeError) {
          throw {
                RE_EXN_ID: Json_decode.DecodeError,
                _1: msg._1 + "\n\tin tuple6",
                Error: new Error()
              };
        }
        throw msg;
      }
    } else {
      throw {
            RE_EXN_ID: Json_decode.DecodeError,
            _1: "Expected array of length 6, got array of length " + length,
            Error: new Error()
          };
    }
  } else {
    throw {
          RE_EXN_ID: Json_decode.DecodeError,
          _1: "Expected array, got " + JSON.stringify(json),
          Error: new Error()
        };
  }
}

var Decode = {
  sum: sum,
  maybe: maybe,
  tuple5: tuple5,
  tuple6: tuple6
};

function tuple5$1(encodeA, encodeB, encodeC, encodeD, encodeE, param) {
  return [
          Curry._1(encodeA, param[0]),
          Curry._1(encodeB, param[1]),
          Curry._1(encodeC, param[2]),
          Curry._1(encodeD, param[3]),
          Curry._1(encodeE, param[4])
        ];
}

function tuple6$1(encodeA, encodeB, encodeC, encodeD, encodeE, encodeF, param) {
  return [
          Curry._1(encodeA, param[0]),
          Curry._1(encodeB, param[1]),
          Curry._1(encodeC, param[2]),
          Curry._1(encodeD, param[3]),
          Curry._1(encodeE, param[4]),
          Curry._1(encodeF, param[5])
        ];
}

var Encode = {
  tuple5: tuple5$1,
  tuple6: tuple6$1
};

function manyIn(elems, elem) {
  return Caml_splice_call.spliceApply(React.createElement, [
              elem,
              {},
              elems
            ]);
}

function manyIn2(elems, elem, props) {
  return Caml_splice_call.spliceApply(React.createElement, [
              elem,
              props,
              elems
            ]);
}

function sepBy$p(item, sep) {
  if (!item) {
    return React.createElement(React.Fragment, undefined);
  }
  var xs = item.tl;
  var x = item.hd;
  if (xs) {
    return manyIn(Belt_List.toArray({
                    hd: x,
                    tl: Belt_List.map(xs, (function (i) {
                            return React.createElement(React.Fragment, undefined, sep, i);
                          }))
                  }), "span");
  } else {
    return x;
  }
}

function sepBy(sep, xs) {
  return sepBy$p(Belt_List.fromArray(xs), sep);
}

function enclosedBy(front, back, item) {
  return React.createElement(React.Fragment, undefined, front, " ", item, " ", back);
}

function when_(p, className) {
  if (p) {
    return " " + className;
  } else {
    return "";
  }
}

function showWhen(x) {
  if (x) {
    return "";
  } else {
    return " hidden";
  }
}

var React$1 = {
  manyIn: manyIn,
  manyIn2: manyIn2,
  sepBy$p: sepBy$p,
  sepBy: sepBy,
  enclosedBy: enclosedBy,
  when_: when_,
  showWhen: showWhen
};

function toString(_e) {
  return (_e.toString());
}

var Exn = {
  toString: toString
};

var partial_arg = /-.*/;

function trim(param) {
  return param.replace(partial_arg, "");
}

function compare(a, b) {
  var match = CompareVersions(Curry._1(trim, a), Curry._1(trim, b));
  if (match !== -1) {
    if (match !== 0) {
      return /* GT */2;
    } else {
      return /* EQ */1;
    }
  } else {
    return /* LT */0;
  }
}

function gte(a, b) {
  var match = compare(a, b);
  return match !== 0;
}

var Version = {
  trim: trim,
  compare: compare,
  gte: gte
};

var React$p;

exports.$$Promise = $$Promise$1;
exports.Decode = Decode;
exports.Encode = Encode;
exports.React$p = React$p;
exports.React = React$1;
exports.Exn = Exn;
exports.Version = Version;
/* react Not a pure module */
