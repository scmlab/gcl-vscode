// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Vscode = require("vscode");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Vscode$Guacamole = require("../Vscode.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Impl__View$Guacamole = require("./Impl__View.bs.js");

function make(prim) {
  return new Vscode.Disposable(prim);
}

function dispose(prim) {
  return prim.dispose();
}

var Disposable = {
  make: make,
  dispose: dispose
};

function make$1(prim, prim$1) {
  return new Vscode.Position(prim, prim$1);
}

function line(prim) {
  return prim.line;
}

function column(prim) {
  return prim.character;
}

function translate(prim, prim$1, prim$2) {
  return prim.translate(prim$1, prim$2);
}

function fromPos(param) {
  return new Vscode.Position(param[1] - 1 | 0, param[2] - 1 | 0);
}

function toPos(point, filepath) {
  return /* Pos */Caml_chrome_debugger.simpleVariant("Pos", [
            filepath,
            point.line + 1 | 0,
            point.character + 1 | 0
          ]);
}

var Point = {
  make: make$1,
  line: line,
  column: column,
  translate: translate,
  fromPos: fromPos,
  toPos: toPos
};

function make$2(prim, prim$1) {
  return new Vscode.Range(prim, prim$1);
}

function start(prim) {
  return prim.start;
}

function end_(prim) {
  return prim.end;
}

function fromLoc(param) {
  if (param) {
    var match = param[1];
    return new Vscode.Range(fromPos(param[0]), new Vscode.Position(match[1] - 1 | 0, match[2]));
  } else {
    return new Vscode.Range(new Vscode.Position(0, 0), new Vscode.Position(0, 0));
  }
}

function toLoc(range, filepath) {
  var start = range.start;
  var end_ = range.end;
  return /* Loc */Caml_chrome_debugger.simpleVariant("Loc", [
            /* Pos */Caml_chrome_debugger.simpleVariant("Pos", [
                filepath,
                start.line + 1 | 0,
                start.character + 1 | 0
              ]),
            /* Pos */Caml_chrome_debugger.simpleVariant("Pos", [
                filepath,
                end_.line + 1 | 0,
                end_.character
              ])
          ]);
}

function contains(prim, prim$1) {
  return prim.contains(prim$1);
}

function containsRange(prim, prim$1) {
  return prim.contains(prim$1);
}

var $$Range = {
  make: make$2,
  start: start,
  end_: end_,
  fromLoc: fromLoc,
  toLoc: toLoc,
  contains: contains,
  containsRange: containsRange
};

function getExtensionPath(context) {
  return context.extensionPath;
}

function getFileName(editor) {
  return editor.document.fileName;
}

function save(editor) {
  return editor.document.save();
}

function addToSubscriptions(disposable, context) {
  context.subscriptions.push(disposable);
  return /* () */0;
}

function onDidCloseEditor(callback) {
  return Vscode.workspace.onDidCloseTextDocument((function (textDoc) {
                return Belt_Option.forEach(textDoc, (function (textDoc) {
                              return Curry._1(callback, textDoc.fileName);
                            }));
              }));
}

function onDidChangeFileName(callback) {
  return Vscode.workspace.onDidRenameFiles((function ($$event) {
                return Belt_Option.forEach(Belt_Option.map($$event, (function (prim) {
                                  return prim.files;
                                })), (function (files) {
                              return Belt_Array.forEach(files, (function (file) {
                                            return Curry._2(callback, file.oldUri.path, file.newUri.path);
                                          }));
                            }));
              }));
}

function onDidChangeActivation(callback) {
  var previous = {
    contents: Belt_Option.flatMap(Vscode.window.activeTextEditor, getFileName)
  };
  return Vscode.window.onDidChangeActiveTextEditor((function (next) {
                var next$1 = Belt_Option.flatMap(next, getFileName);
                if (Caml_obj.caml_notequal(next$1, previous.contents)) {
                  Curry._2(callback, previous.contents, next$1);
                  previous.contents = next$1;
                  return /* () */0;
                } else {
                  return 0;
                }
              }));
}

function registerCommand(name, callback) {
  return Vscode.commands.registerCommand("extension." + name, (function (param) {
                return Belt_Option.forEach(Vscode.window.activeTextEditor, (function (editor) {
                              return Belt_Option.forEach(editor.document.fileName, (function (fileName) {
                                            var partial_arg = /\.gcl$/i;
                                            var isGCL = function (param) {
                                              return partial_arg.test(param);
                                            };
                                            if (Curry._1(isGCL, fileName)) {
                                              return Curry._1(callback, editor);
                                            } else {
                                              return 0;
                                            }
                                          }));
                            }));
              }));
}

function setGCLPath(path) {
  return Vscode.workspace.getConfiguration("guacamole", undefined).update("gclPath", path, 1, undefined);
}

function getGCLPath(param) {
  return Vscode.workspace.getConfiguration("guacamole", undefined).get("gclPath");
}

var Config = {
  setGCLPath: setGCLPath,
  getGCLPath: getGCLPath
};

function make$3(param, param$1) {
  return Impl__View$Guacamole.make(getExtensionPath, param, param$1);
}

var View = {
  send: Impl__View$Guacamole.send,
  recv: Impl__View$Guacamole.recv,
  destroy: Impl__View$Guacamole.destroy,
  show: Impl__View$Guacamole.show,
  hide: Impl__View$Guacamole.hide,
  make: make$3
};

function digHole(editor, range) {
  var start = range.start;
  var indent = " ".repeat(start.character);
  var holeText = "{!\n" + (indent + ("\n" + (indent + "!}")));
  var holeRange = new Vscode.Range(start, start.translate(0, 1));
  var editCallback = function (edit) {
    edit.replace(holeRange, holeText);
    return /* () */0;
  };
  editor.edit(editCallback, undefined);
  var pos = start.translate(1, 0);
  var selection = new Vscode.Selection(pos, pos);
  editor.selection = selection;
  return /* () */0;
}

function highlightBackground(editor, kind, range) {
  var tmp;
  switch (kind) {
    case /* Error */0 :
        tmp = new Vscode.ThemeColor("inputValidation.errorBackground");
        break;
    case /* Highlight */1 :
        tmp = new Vscode.ThemeColor("editor.symbolHighlightBackground");
        break;
    case /* Spec */2 :
        tmp = new Vscode.ThemeColor("editor.wordHighlightStrongBackground");
        break;
    
  }
  var backgroundColor = Vscode$Guacamole.ThemeColor.themeColor(tmp);
  var options = {
    backgroundColor: backgroundColor
  };
  var handle = Vscode.window.createTextEditorDecorationType(options);
  editor.setDecorations(handle, [range]);
  return [handle];
}

function overlayText(editor, kind, text, range) {
  var tmp;
  switch (kind) {
    case /* Error */0 :
        tmp = new Vscode.ThemeColor("errorForeground");
        break;
    case /* Highlight */1 :
    case /* Spec */2 :
        tmp = new Vscode.ThemeColor("descriptionForeground");
        break;
    
  }
  var after = {
    color: Vscode$Guacamole.ThemeColor.themeColor(tmp),
    contentText: text
  };
  var options = {
    after: after
  };
  var handle = Vscode.window.createTextEditorDecorationType(options);
  editor.setDecorations(handle, [range]);
  return [handle];
}

function destroy(prim) {
  prim.dispose();
  return /* () */0;
}

var Decoration = {
  digHole: digHole,
  highlightBackground: highlightBackground,
  overlayText: overlayText,
  destroy: destroy
};

function getCursorPosition(editor) {
  return editor.selection.end;
}

function textForRange(editor, range) {
  return editor.document.getText(Caml_option.some(range));
}

function rangeForLine(editor, line) {
  return editor.document.lineAt(line).range;
}

function getText(editor, range) {
  return editor.document.getText(Caml_option.some(range));
}

function selectText(editor, range) {
  var start = range.start;
  var end_ = range.end;
  var selection = new Vscode.Selection(start, end_);
  editor.selection = selection;
  return /* () */0;
}

function insertText(editor, point, text) {
  var editCallback = function (edit) {
    edit.insert(point, text);
    return /* () */0;
  };
  return editor.edit(editCallback, undefined);
}

function deleteText(editor, range) {
  var editCallback = function (edit) {
    edit.delete(range);
    return /* () */0;
  };
  return editor.edit(editCallback, undefined);
}

var editorType = /* VsCode */1;

exports.Disposable = Disposable;
exports.Point = Point;
exports.$$Range = $$Range;
exports.editorType = editorType;
exports.getExtensionPath = getExtensionPath;
exports.getFileName = getFileName;
exports.save = save;
exports.addToSubscriptions = addToSubscriptions;
exports.onDidCloseEditor = onDidCloseEditor;
exports.onDidChangeFileName = onDidChangeFileName;
exports.onDidChangeActivation = onDidChangeActivation;
exports.registerCommand = registerCommand;
exports.Config = Config;
exports.View = View;
exports.Decoration = Decoration;
exports.getCursorPosition = getCursorPosition;
exports.textForRange = textForRange;
exports.rangeForLine = rangeForLine;
exports.getText = getText;
exports.selectText = selectText;
exports.insertText = insertText;
exports.deleteText = deleteText;
/* vscode Not a pure module */
