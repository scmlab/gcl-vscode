// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var Ok$Guacamole = require("../Util/Ok.bs.js");
var GCL$Guacamole = require("../GCL.bs.js");
var Event$Guacamole = require("../Util/Event.bs.js");
var Request$Guacamole = require("../Request.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Connection$Guacamole = require("../Connection.bs.js");

function Impl(Editor) {
  var getEditor = function (state) {
    return state.editor;
  };
  var setSpecifications = function (state, specifications) {
    state.specifications = specifications;
    return /* () */0;
  };
  var onDestroy = function (state, callback) {
    return Curry._1(Editor.Disposable.make, Curry._1(state.onDestroyEventEmitter.on, callback));
  };
  var connect = function (state) {
    var match = state.connection;
    if (match !== undefined) {
      return $$Promise.resolved(/* Ok */Caml_chrome_debugger.variant("Ok", 0, [match]));
    } else {
      return $$Promise.tapOk($$Promise.mapError(Connection$Guacamole.make(Editor.Config.getGCLPath, Editor.Config.setGCLPath), (function (e) {
                        return /* Connection */Caml_chrome_debugger.variant("Connection", 0, [e]);
                      })), (function (conn) {
                    state.connection = conn;
                    return /* () */0;
                  }));
    }
  };
  var disconnect = function (state) {
    var match = state.connection;
    if (match !== undefined) {
      return Connection$Guacamole.disconnect(match);
    } else {
      return $$Promise.resolved(/* () */0);
    }
  };
  var sendRequest = function (state, request) {
    var value = Request$Guacamole.encode(request);
    console.log("<<<", value);
    return Ok$Guacamole.let_(connect(state), (function (conn) {
                  return Ok$Guacamole.let_($$Promise.mapError(Connection$Guacamole.send(value, conn), (function (e) {
                                    return /* Connection */Caml_chrome_debugger.variant("Connection", 0, [e]);
                                  })), (function (result) {
                                console.log(">>>", JSON.stringify(result).substring(0, 200));
                                var value;
                                try {
                                  value = Curry._1(GCL$Guacamole.$$Response.decode, result);
                                }
                                catch (raw_exn){
                                  var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                                  if (exn[0] === Json_decode.DecodeError) {
                                    return $$Promise.resolved(/* Error */Caml_chrome_debugger.variant("Error", 1, [/* Decode */Caml_chrome_debugger.variant("Decode", 1, [
                                                      exn[1],
                                                      result
                                                    ])]));
                                  } else {
                                    throw exn;
                                  }
                                }
                                return $$Promise.resolved(/* Ok */Caml_chrome_debugger.variant("Ok", 0, [value]));
                              }));
                }));
  };
  var destroy = function (state) {
    Curry._1(Editor.View.destroy, state.view);
    Curry._1(state.onDestroyEventEmitter.destroy, /* () */0);
    Curry._1(state.onDestroyEventEmitter.emit, /* () */0);
    Belt_Array.forEach(state.decorations, Editor.Decoration.destroy);
    return disconnect(state);
  };
  var make = function (context, editor) {
    var view = Curry._2(Editor.View.make, context, editor);
    var state = {
      editor: editor,
      context: context,
      view: view,
      mode: /* WP1 */0,
      decorations: [],
      specifications: [],
      connection: undefined,
      onDestroyEventEmitter: Event$Guacamole.make(/* () */0)
    };
    var decorationDict = { };
    var delete_ = (function (id) {delete decorationDict[id]});
    var onRecvMessageFromView = function (x) {
      if (typeof x === "number") {
        if (x === /* Initialized */0) {
          return /* () */0;
        } else {
          destroy(state);
          return /* () */0;
        }
      } else if (x.tag) {
        var match = x[0];
        switch (match.tag | 0) {
          case /* MouseOver */0 :
              var loc = match[0];
              var key = GCL$Guacamole.Loc.toString(loc);
              var range = Curry._1(Editor.$$Range.fromLoc, loc);
              var decoration = Curry._3(Editor.Decoration.highlightBackground, editor, /* Highlight */1, range);
              decorationDict[key] = decoration;
              return /* () */0;
          case /* MouseOut */1 :
              var key$1 = GCL$Guacamole.Loc.toString(match[0]);
              Belt_Option.forEach(Js_dict.get(decorationDict, key$1), (function (decos) {
                      return Belt_Array.forEach(decos, Editor.Decoration.destroy);
                    }));
              return delete_(key$1);
          case /* MouseClick */2 :
              var range$1 = Curry._1(Editor.$$Range.fromLoc, match[0]);
              return Curry._2(Editor.select, editor, range$1);
          
        }
      } else {
        state.mode = x[0];
        return /* () */0;
      }
    };
    Curry._2(Editor.addToSubscriptions, Curry._2(Editor.View.recv, view, onRecvMessageFromView), context);
    return state;
  };
  var show = function (state) {
    return Curry._1(Editor.View.show, state.view);
  };
  var hide = function (state) {
    return Curry._1(Editor.View.hide, state.view);
  };
  var display = function (state, header, body) {
    return Curry._2(Editor.View.send, state.view, /* Display */Caml_chrome_debugger.simpleVariant("Display", [
                  header,
                  body
                ]));
  };
  var fromCursorPosition = function (state) {
    var cursor = Curry._1(Editor.getCursorPosition, state.editor);
    var smallestHole = {
      contents: undefined
    };
    Belt_Array.forEach(Belt_Array.keep(state.specifications, (function (spec) {
                var range = Curry._1(Editor.$$Range.fromLoc, spec.loc);
                return Curry._2(Editor.$$Range.contains, range, cursor);
              })), (function (spec) {
            var match = smallestHole.contents;
            if (match !== undefined && !Curry._2(Editor.$$Range.containsRange, Curry._1(Editor.$$Range.fromLoc, spec.loc), Curry._1(Editor.$$Range.fromLoc, match.loc))) {
              return 0;
            } else {
              smallestHole.contents = spec;
              return /* () */0;
            }
          }));
    return smallestHole.contents;
  };
  var getPayloadRange = function (editor, spec) {
    var range = Curry._1(Editor.$$Range.fromLoc, spec.loc);
    var startingLine = Curry._1(Editor.Point.line, Curry._1(Editor.$$Range.start, range)) + 1 | 0;
    var endingLine = Curry._1(Editor.Point.line, Curry._1(Editor.$$Range.end_, range)) - 1 | 0;
    var start = Curry._1(Editor.$$Range.start, Curry._2(Editor.rangeForLine, editor, startingLine));
    var end_ = Curry._1(Editor.$$Range.end_, Curry._2(Editor.rangeForLine, editor, endingLine));
    return Curry._2(Editor.$$Range.make, start, end_);
  };
  var getPayload = function (editor, spec) {
    var innerRange = getPayloadRange(editor, spec);
    return Curry._2(Editor.textForRange, editor, innerRange);
  };
  var Spec = {
    fromCursorPosition: fromCursorPosition,
    getPayloadRange: getPayloadRange,
    getPayload: getPayload
  };
  return {
          getEditor: getEditor,
          setSpecifications: setSpecifications,
          onDestroy: onDestroy,
          connect: connect,
          disconnect: disconnect,
          sendRequest: sendRequest,
          destroy: destroy,
          make: make,
          show: show,
          hide: hide,
          display: display,
          Spec: Spec
        };
}

exports.Impl = Impl;
/* Promise Not a pure module */
