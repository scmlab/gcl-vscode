// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Url = require("url");
var Curry = require("bs-platform/lib/js/curry.js");
var Https = require("https");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Process = require("process");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Result = require("bs-platform/lib/js/belt_Result.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var Constant$Guacamole = require("./Constant.bs.js");

function readFile(path) {
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  Fs.readFile(path, (function (error, buffer) {
          if (error !== undefined) {
            return Curry._1(resolve, {
                        TAG: 1,
                        _0: Caml_option.valFromOption(error),
                        [Symbol.for("name")]: "Error"
                      });
          } else {
            return Curry._1(resolve, {
                        TAG: 0,
                        _0: buffer,
                        [Symbol.for("name")]: "Ok"
                      });
          }
        }));
  return match[0];
}

var Fs$1 = {
  readFile: readFile
};

var Https$1 = {};

var Url$1 = {};

var Nd = {
  Fs: Fs$1,
  Https: Https$1,
  Url: Url$1
};

var $$Error = {};

function gatherDataFromResponse(res) {
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  var body = {
    contents: ""
  };
  res.on("data", (function (buf) {
          body.contents = body.contents + buf.toString();
          
        }));
  res.on("error", (function (error) {
          return Curry._1(resolve, {
                      TAG: 1,
                      _0: {
                        TAG: 2,
                        _0: error,
                        [Symbol.for("name")]: "ServerResponseError"
                      },
                      [Symbol.for("name")]: "Error"
                    });
        }));
  res.on("close", (function () {
          return Curry._1(resolve, {
                      TAG: 0,
                      _0: body.contents,
                      [Symbol.for("name")]: "Ok"
                    });
        }));
  return match[0];
}

function getWithRedirects(options) {
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  Https.get(options, (function (res) {
          var statusCode = res.statusCode;
          if (!(statusCode === 302 || statusCode === 301)) {
            return $$Promise.get(gatherDataFromResponse(res), resolve);
          }
          var headers = res.getHeaders();
          var urlAfterRedirect = headers.location;
          if (urlAfterRedirect !== undefined) {
            Https.get(urlAfterRedirect, (function (resAfterRedirect) {
                    return $$Promise.get(gatherDataFromResponse(resAfterRedirect), resolve);
                  }));
            return ;
          } else {
            return Curry._1(resolve, {
                        TAG: 1,
                        _0: /* NoRedirectLocation */0,
                        [Symbol.for("name")]: "Error"
                      });
          }
        }));
  return match[0];
}

var HTTP = {
  gatherDataFromResponse: gatherDataFromResponse,
  getWithRedirects: getWithRedirects
};

function decodeAsset(json) {
  return {
          name: Json_decode.field("name", Json_decode.string, json),
          url: Json_decode.field("browser_download_url", Json_decode.string, json)
        };
}

function decode(json) {
  return {
          tagName: Json_decode.field("tag_name", Json_decode.string, json),
          assets: Json_decode.field("assets", (function (param) {
                  return Json_decode.array(decodeAsset, param);
                }), json)
        };
}

function parseMetadata(json) {
  try {
    return {
            TAG: 0,
            _0: Json_decode.array(decode, json),
            [Symbol.for("name")]: "Ok"
          };
  }
  catch (raw_e){
    var e = Caml_js_exceptions.internalToOCamlException(raw_e);
    if (e.RE_EXN_ID === Json_decode.DecodeError) {
      return {
              TAG: 1,
              _0: {
                TAG: 1,
                _0: e._1,
                _1: json,
                [Symbol.for("name")]: "ResponseDecodeError"
              },
              [Symbol.for("name")]: "Error"
            };
    }
    throw e;
  }
}

function getReleasesFromGitHub(param) {
  var httpOptions = {
    host: "api.github.com",
    path: "/repos/scmlab/gcl/releases",
    headers: {
      "User-Agent": "gcl-vscode"
    }
  };
  return $$Promise.flatMapOk(getWithRedirects(httpOptions), (function (raw) {
                try {
                  return $$Promise.resolved(parseMetadata(JSON.parse(raw)));
                }
                catch (exn){
                  return $$Promise.resolved({
                              TAG: 1,
                              _0: {
                                TAG: 0,
                                _0: raw,
                                [Symbol.for("name")]: "ResponseParseError"
                              },
                              [Symbol.for("name")]: "Error"
                            });
                }
              }));
}

var Release = {
  decodeAsset: decodeAsset,
  decode: decode,
  parseMetadata: parseMetadata,
  getReleasesFromGitHub: getReleasesFromGitHub
};

function downloadLanguageServer(context) {
  var globalStoragePath = context.globalStoragePath;
  if (!Fs.existsSync(globalStoragePath)) {
    Fs.mkdirSync(globalStoragePath);
  }
  var getMatchingRelease = function (releases) {
    var matched = Belt_Array.keep(releases, (function (release) {
            return release.tagName === Constant$Guacamole.version;
          }));
    var release = Belt_Array.get(matched, 0);
    if (release !== undefined) {
      return $$Promise.resolved({
                  TAG: 0,
                  _0: release,
                  [Symbol.for("name")]: "Ok"
                });
    } else {
      return $$Promise.resolved({
                  TAG: 1,
                  _0: {
                    TAG: 3,
                    _0: Constant$Guacamole.version,
                    [Symbol.for("name")]: "NoMatchingVersion"
                  },
                  [Symbol.for("name")]: "Error"
                });
    }
  };
  var getMatchingAsset = function (release) {
    var os = Process.platform;
    var expectedName;
    switch (os) {
      case "darwin" :
          expectedName = {
            TAG: 0,
            _0: "gcl-macos.zip",
            [Symbol.for("name")]: "Ok"
          };
          break;
      case "linux" :
          expectedName = {
            TAG: 0,
            _0: "gcl-ubuntu.zip",
            [Symbol.for("name")]: "Ok"
          };
          break;
      case "win32" :
          expectedName = {
            TAG: 0,
            _0: "gcl-windows.zip",
            [Symbol.for("name")]: "Ok"
          };
          break;
      default:
        expectedName = {
          TAG: 1,
          _0: {
            TAG: 4,
            _0: os,
            [Symbol.for("name")]: "NotSupportedOS"
          },
          [Symbol.for("name")]: "Error"
        };
    }
    return $$Promise.resolved(Belt_Result.flatMap(expectedName, (function (name) {
                      var matched = Belt_Array.keep(release.assets, (function (asset) {
                              return asset.name === name;
                            }));
                      var asset = Belt_Array.get(matched, 0);
                      if (asset !== undefined) {
                        return {
                                TAG: 0,
                                _0: asset,
                                [Symbol.for("name")]: "Ok"
                              };
                      } else {
                        return {
                                TAG: 1,
                                _0: {
                                  TAG: 4,
                                  _0: os,
                                  [Symbol.for("name")]: "NotSupportedOS"
                                },
                                [Symbol.for("name")]: "Error"
                              };
                      }
                    })));
  };
  return $$Promise.flatMapOk($$Promise.flatMapOk($$Promise.flatMapOk(getReleasesFromGitHub(undefined), getMatchingRelease), getMatchingAsset), (function (asset) {
                var url = Url.parse(asset.url);
                return getWithRedirects({
                            host: url.host,
                            path: url.path,
                            headers: {
                              "User-Agent": "gcl-vscode"
                            }
                          });
              }));
}

exports.Nd = Nd;
exports.$$Error = $$Error;
exports.HTTP = HTTP;
exports.Release = Release;
exports.downloadLanguageServer = downloadLanguageServer;
/* fs Not a pure module */
