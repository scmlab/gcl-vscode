// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Url = require("url");
var Path = require("path");
var Curry = require("bs-platform/lib/js/curry.js");
var Https = require("https");
var Yauzl = require("yauzl");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Process = require("process");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Result = require("bs-platform/lib/js/belt_Result.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var Constant$Guacamole = require("./Constant.bs.js");

function readFile(path) {
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  Fs.readFile(path, (function (error, buffer) {
          if (error !== undefined) {
            return Curry._1(resolve, {
                        TAG: 1,
                        _0: Caml_option.valFromOption(error),
                        [Symbol.for("name")]: "Error"
                      });
          } else {
            return Curry._1(resolve, {
                        TAG: 0,
                        _0: buffer,
                        [Symbol.for("name")]: "Ok"
                      });
          }
        }));
  return match[0];
}

var Fs$1 = {
  readFile: readFile
};

var Https$1 = {};

var Url$1 = {};

var Nd = {
  Fs: Fs$1,
  Https: Https$1,
  Url: Url$1
};

var Entry = {};

var ZipFile = {};

var Yauzl$1 = {
  Entry: Entry,
  ZipFile: ZipFile
};

var $$Error = {};

function gatherDataFromResponse(res) {
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  var body = {
    contents: ""
  };
  res.on("data", (function (buf) {
          body.contents = body.contents + buf.toString();
          
        }));
  res.on("error", (function (error) {
          return Curry._1(resolve, {
                      TAG: 1,
                      _0: {
                        TAG: 2,
                        _0: error,
                        [Symbol.for("name")]: "ServerResponseError"
                      },
                      [Symbol.for("name")]: "Error"
                    });
        }));
  res.on("close", (function () {
          return Curry._1(resolve, {
                      TAG: 0,
                      _0: body.contents,
                      [Symbol.for("name")]: "Ok"
                    });
        }));
  return match[0];
}

function getWithRedirects(options) {
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  Https.get(options, (function (res) {
          var statusCode = res.statusCode;
          if (!(statusCode === 302 || statusCode === 301)) {
            return Curry._1(resolve, {
                        TAG: 0,
                        _0: res,
                        [Symbol.for("name")]: "Ok"
                      });
          }
          var headers = res.headers;
          var urlAfterRedirect = headers.location;
          if (urlAfterRedirect !== undefined) {
            Https.get(urlAfterRedirect, (function (resAfterRedirect) {
                    return Curry._1(resolve, {
                                TAG: 0,
                                _0: resAfterRedirect,
                                [Symbol.for("name")]: "Ok"
                              });
                  }));
            return ;
          } else {
            return Curry._1(resolve, {
                        TAG: 1,
                        _0: /* NoRedirectLocation */0,
                        [Symbol.for("name")]: "Error"
                      });
          }
        }));
  return match[0];
}

var HTTP = {
  gatherDataFromResponse: gatherDataFromResponse,
  getWithRedirects: getWithRedirects
};

function decodeAsset(json) {
  return {
          name: Json_decode.field("name", Json_decode.string, json),
          url: Json_decode.field("browser_download_url", Json_decode.string, json)
        };
}

function decode(json) {
  return {
          tagName: Json_decode.field("tag_name", Json_decode.string, json),
          assets: Json_decode.field("assets", (function (param) {
                  return Json_decode.array(decodeAsset, param);
                }), json)
        };
}

function parseMetadata(json) {
  try {
    return {
            TAG: 0,
            _0: Json_decode.array(decode, json),
            [Symbol.for("name")]: "Ok"
          };
  }
  catch (raw_e){
    var e = Caml_js_exceptions.internalToOCamlException(raw_e);
    if (e.RE_EXN_ID === Json_decode.DecodeError) {
      return {
              TAG: 1,
              _0: {
                TAG: 1,
                _0: e._1,
                _1: json,
                [Symbol.for("name")]: "ResponseDecodeError"
              },
              [Symbol.for("name")]: "Error"
            };
    }
    throw e;
  }
}

function getReleasesFromGitHub(param) {
  var httpOptions = {
    host: "api.github.com",
    path: "/repos/scmlab/gcl/releases",
    headers: {
      "User-Agent": "gcl-vscode"
    }
  };
  return $$Promise.flatMapOk($$Promise.flatMapOk(getWithRedirects(httpOptions), gatherDataFromResponse), (function (raw) {
                try {
                  return $$Promise.resolved(parseMetadata(JSON.parse(raw)));
                }
                catch (exn){
                  return $$Promise.resolved({
                              TAG: 1,
                              _0: {
                                TAG: 0,
                                _0: raw,
                                [Symbol.for("name")]: "ResponseParseError"
                              },
                              [Symbol.for("name")]: "Error"
                            });
                }
              }));
}

var Release = {
  decodeAsset: decodeAsset,
  decode: decode,
  parseMetadata: parseMetadata,
  getReleasesFromGitHub: getReleasesFromGitHub
};

function downloadLanguageServer(context) {
  var globalStoragePath = context.globalStoragePath;
  if (!Fs.existsSync(globalStoragePath)) {
    Fs.mkdirSync(globalStoragePath);
  }
  var getMatchingRelease = function (releases) {
    var matched = Belt_Array.keep(releases, (function (release) {
            return release.tagName === Constant$Guacamole.version;
          }));
    var release = Belt_Array.get(matched, 0);
    if (release !== undefined) {
      return $$Promise.resolved({
                  TAG: 0,
                  _0: release,
                  [Symbol.for("name")]: "Ok"
                });
    } else {
      return $$Promise.resolved({
                  TAG: 1,
                  _0: {
                    TAG: 3,
                    _0: Constant$Guacamole.version,
                    [Symbol.for("name")]: "NoMatchingVersion"
                  },
                  [Symbol.for("name")]: "Error"
                });
    }
  };
  var getMatchingAsset = function (release) {
    var os = Process.platform;
    var expectedName;
    switch (os) {
      case "darwin" :
          expectedName = {
            TAG: 0,
            _0: "gcl-macos.zip",
            [Symbol.for("name")]: "Ok"
          };
          break;
      case "linux" :
          expectedName = {
            TAG: 0,
            _0: "gcl-ubuntu.zip",
            [Symbol.for("name")]: "Ok"
          };
          break;
      case "win32" :
          expectedName = {
            TAG: 0,
            _0: "gcl-windows.zip",
            [Symbol.for("name")]: "Ok"
          };
          break;
      default:
        expectedName = {
          TAG: 1,
          _0: {
            TAG: 4,
            _0: os,
            [Symbol.for("name")]: "NotSupportedOS"
          },
          [Symbol.for("name")]: "Error"
        };
    }
    return $$Promise.resolved(Belt_Result.flatMap(expectedName, (function (name) {
                      var matched = Belt_Array.keep(release.assets, (function (asset) {
                              return asset.name === name;
                            }));
                      var asset = Belt_Array.get(matched, 0);
                      if (asset !== undefined) {
                        return {
                                TAG: 0,
                                _0: [
                                  release,
                                  asset
                                ],
                                [Symbol.for("name")]: "Ok"
                              };
                      } else {
                        return {
                                TAG: 1,
                                _0: {
                                  TAG: 4,
                                  _0: os,
                                  [Symbol.for("name")]: "NotSupportedOS"
                                },
                                [Symbol.for("name")]: "Error"
                              };
                      }
                    })));
  };
  return $$Promise.tapOk($$Promise.flatMapOk($$Promise.flatMapOk($$Promise.flatMapOk($$Promise.flatMapOk($$Promise.flatMapOk(getReleasesFromGitHub(undefined), getMatchingRelease), getMatchingAsset), (function (param) {
                            var asset = param[1];
                            var release = param[0];
                            var url = Url.parse(asset.url);
                            var httpOptions = {
                              host: url.host,
                              path: url.path,
                              headers: {
                                "User-Agent": "gcl-vscode"
                              }
                            };
                            return $$Promise.mapOk(getWithRedirects(httpOptions), (function (res) {
                                          return [
                                                  release,
                                                  asset,
                                                  res
                                                ];
                                        }));
                          })), (function (param) {
                        var asset = param[1];
                        var release = param[0];
                        var match = $$Promise.pending(undefined);
                        var resolve = match[1];
                        var osName = asset.name.slice(4, -4);
                        var outputPath = Path.join(globalStoragePath, "gcl-" + release.tagName + "-" + osName);
                        var zipPath = outputPath + ".zip";
                        var zipFileStream = Fs.createWriteStream(zipPath);
                        zipFileStream.on("error", (function (exn) {
                                return Curry._1(resolve, {
                                            TAG: 1,
                                            _0: {
                                              TAG: 5,
                                              _0: exn,
                                              [Symbol.for("name")]: "CannotWriteFile"
                                            },
                                            [Symbol.for("name")]: "Error"
                                          });
                              }));
                        zipFileStream.on("close", (function () {
                                return Curry._1(resolve, {
                                            TAG: 0,
                                            _0: outputPath,
                                            [Symbol.for("name")]: "Ok"
                                          });
                              }));
                        param[2].pipe(zipFileStream);
                        console.log(release);
                        console.log(asset);
                        console.log(outputPath);
                        return match[0];
                      })), (function (outputPath) {
                    var match = $$Promise.pending(undefined);
                    var resolve = match[1];
                    var outputFileStream = Fs.createWriteStream(outputPath);
                    var zipPath = outputPath + ".zip";
                    Yauzl.open(zipPath, (function (param) {
                            var result = param[1];
                            var err = param[0];
                            if (err !== undefined) {
                              return Curry._1(resolve, {
                                          TAG: 1,
                                          _0: {
                                            TAG: 6,
                                            _0: Caml_option.valFromOption(err),
                                            [Symbol.for("name")]: "CannotUnzipFileWithExn"
                                          },
                                          [Symbol.for("name")]: "Error"
                                        });
                            }
                            if (result === undefined) {
                              return Curry._1(resolve, {
                                          TAG: 1,
                                          _0: /* CannotUnzipFile */1,
                                          [Symbol.for("name")]: "Error"
                                        });
                            }
                            var zipFile = Caml_option.valFromOption(result);
                            zipFile.on("entry", (function (entry) {
                                    zipFile.openReadStream(entry, (function (err2, result2) {
                                            if (err2 !== undefined) {
                                              return Curry._1(resolve, {
                                                          TAG: 1,
                                                          _0: {
                                                            TAG: 6,
                                                            _0: Caml_option.valFromOption(err2),
                                                            [Symbol.for("name")]: "CannotUnzipFileWithExn"
                                                          },
                                                          [Symbol.for("name")]: "Error"
                                                        });
                                            } else if (result2 !== undefined) {
                                              Caml_option.valFromOption(result2).pipe(outputFileStream);
                                              return ;
                                            } else {
                                              return Curry._1(resolve, {
                                                          TAG: 1,
                                                          _0: /* CannotUnzipFile */1,
                                                          [Symbol.for("name")]: "Error"
                                                        });
                                            }
                                          }));
                                    
                                  }));
                            
                          }));
                    outputFileStream.on("error", (function (exn) {
                            return Curry._1(resolve, {
                                        TAG: 1,
                                        _0: {
                                          TAG: 6,
                                          _0: exn,
                                          [Symbol.for("name")]: "CannotUnzipFileWithExn"
                                        },
                                        [Symbol.for("name")]: "Error"
                                      });
                          }));
                    outputFileStream.on("close", (function () {
                            return Curry._1(resolve, {
                                        TAG: 0,
                                        _0: outputPath,
                                        [Symbol.for("name")]: "Ok"
                                      });
                          }));
                    return match[0];
                  })), (function (prim) {
                console.log(prim);
                
              }));
}

exports.Nd = Nd;
exports.Yauzl = Yauzl$1;
exports.$$Error = $$Error;
exports.HTTP = HTTP;
exports.Release = Release;
exports.downloadLanguageServer = downloadLanguageServer;
/* fs Not a pure module */
