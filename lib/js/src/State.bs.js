// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var VSCode = require("bs-vscode/lib/js/src/VSCode.bs.js");
var Vscode = require("vscode");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var GCL$Guacamole = require("./GCL.bs.js");
var View$Guacamole = require("./View.bs.js");
var Editor$Guacamole = require("./Editor.bs.js");
var Request$Guacamole = require("./Request.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var Response$Guacamole = require("./Response.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Connection$Guacamole = require("./Connection.bs.js");
var Event$AgdaModeVscode = require("agda-mode-vscode/lib/js/src/Util/Event.bs.js");

function setGCLPath(path) {
  return Vscode.workspace.getConfiguration("guacamole", undefined).update("gclPath", path, 1, undefined);
}

function getGCLPath(param) {
  return Vscode.workspace.getConfiguration("guacamole", undefined).get("gclPath");
}

var Config = {
  setGCLPath: setGCLPath,
  getGCLPath: getGCLPath
};

function setSpecifications(state, specifications) {
  state.specifications = specifications;
  
}

function onDestroy(state, callback) {
  return new Vscode.Disposable(Curry._1(state.onDestroyEventEmitter.on, callback));
}

function connect(state) {
  var connection = state.connection;
  if (connection !== undefined) {
    return $$Promise.resolved(/* Ok */Caml_chrome_debugger.variant("Ok", 0, [connection]));
  } else {
    return $$Promise.tapOk($$Promise.mapError(Connection$Guacamole.make(getGCLPath, setGCLPath), (function (e) {
                      return /* Connection */Caml_chrome_debugger.variant("Connection", 0, [e]);
                    })), (function (conn) {
                  state.connection = conn;
                  
                }));
  }
}

function disconnect(state) {
  var connection = state.connection;
  if (connection !== undefined) {
    return Connection$Guacamole.disconnect(connection);
  } else {
    return $$Promise.resolved(undefined);
  }
}

function sendRequest(state, request) {
  var value = Request$Guacamole.encode(request);
  console.log("<<<", value);
  return $$Promise.flatMapOk($$Promise.flatMapOk(connect(state), (function (conn) {
                    return $$Promise.mapError(Connection$Guacamole.send(value, conn), (function (e) {
                                  return /* Connection */Caml_chrome_debugger.variant("Connection", 0, [e]);
                                }));
                  })), (function (result) {
                console.log(">>>", JSON.stringify(result).substring(0, 200));
                var value;
                try {
                  value = Response$Guacamole.decode(result);
                }
                catch (raw_msg){
                  var msg = Caml_js_exceptions.internalToOCamlException(raw_msg);
                  if (msg[0] === Json_decode.DecodeError) {
                    return $$Promise.resolved(/* Error */Caml_chrome_debugger.variant("Error", 1, [/* Decode */Caml_chrome_debugger.variant("Decode", 1, [
                                      msg[1],
                                      result
                                    ])]));
                  }
                  throw msg;
                }
                return $$Promise.resolved(/* Ok */Caml_chrome_debugger.variant("Ok", 0, [value]));
              }));
}

function destroy(state) {
  View$Guacamole.destroy(state.view);
  Curry._1(state.onDestroyEventEmitter.emit, undefined);
  Curry._1(state.onDestroyEventEmitter.destroy, undefined);
  Belt_Array.forEach(state.decorations, Editor$Guacamole.Decoration.destroy);
  return disconnect(state);
}

function make(extentionPath, disposables, editor) {
  var view = View$Guacamole.make(extentionPath, editor);
  var docSelector = [VSCode.DocumentFilterOrString.documentFilter({
          language: "gcl",
          pattern: undefined,
          scheme: undefined
        })];
  var codeLensProvider_resolveCodeLens = function (param, param$1) {
    console.log("codeLensProvider.resolveCodeLens invoked");
    
  };
  var codeLensProvider_provideCodeLenses = function (param, param$1) {
    console.log("codeLensProvider.provideCodeLenses invoked");
    
  };
  var codeLensProvider = {
    onDidChangeCodeLenses: undefined,
    resolveCodeLens: codeLensProvider_resolveCodeLens,
    provideCodeLenses: codeLensProvider_provideCodeLenses
  };
  console.log("registering");
  disposables.push(Vscode.languages.registerCodeLensProvider(docSelector, codeLensProvider));
  return {
          editor: editor,
          view: view,
          mode: /* WP1 */0,
          decorations: [],
          specifications: [],
          connection: undefined,
          onDestroyEventEmitter: Event$AgdaModeVscode.make(undefined)
        };
}

function show(state) {
  return View$Guacamole.show(state.view);
}

function hide(state) {
  return View$Guacamole.hide(state.view);
}

function sendRequestToView(state, request) {
  return View$Guacamole.send(state.view, request);
}

function display(state, header, body) {
  return View$Guacamole.send(state.view, /* Display */Caml_chrome_debugger.variant("Display", 1, [
                header,
                body
              ]));
}

function fromCursorPosition(state) {
  var cursor = state.editor.selection.end;
  var smallestHole = {
    contents: undefined
  };
  Belt_Array.forEach(Belt_Array.keep(state.specifications, (function (spec) {
              var range = GCL$Guacamole.Loc.toRange(spec.loc);
              return range.contains(cursor);
            })), (function (spec) {
          var spec$prime = smallestHole.contents;
          if (spec$prime !== undefined && !GCL$Guacamole.Loc.toRange(spec.loc).contains(GCL$Guacamole.Loc.toRange(spec$prime.loc))) {
            return ;
          } else {
            smallestHole.contents = spec;
            return ;
          }
        }));
  return smallestHole.contents;
}

function getPayloadRange(doc, spec) {
  var range = GCL$Guacamole.Loc.toRange(spec.loc);
  var startingLine = range.start.line + 1 | 0;
  var endingLine = range.end.line - 1 | 0;
  var start = doc.lineAt(startingLine).range.start;
  var end_ = doc.lineAt(endingLine).range.end;
  return new Vscode.Range(start, end_);
}

function getPayload(doc, spec) {
  var innerRange = getPayloadRange(doc, spec);
  return doc.getText(Caml_option.some(innerRange));
}

function resolve(state, i) {
  var specs = Belt_Array.keep(state.specifications, (function (spec) {
          return spec.id === i;
        }));
  Belt_Option.forEach(Belt_Array.get(specs, 0), (function (spec) {
          var doc = state.editor.document;
          var payload = getPayload(doc, spec);
          var range = GCL$Guacamole.Loc.toRange(spec.loc);
          var start = range.start;
          return $$Promise.get($$Promise.flatMap(Editor$Guacamole.deleteText(doc, range), (function (param) {
                            if (param) {
                              return Editor$Guacamole.insertText(doc, start, payload.trim());
                            } else {
                              return $$Promise.resolved(false);
                            }
                          })), (function (param) {
                        
                      }));
        }));
  return $$Promise.resolved(undefined);
}

function insert(state, lineNo, expr) {
  var assertion = "{ " + (Curry._1(GCL$Guacamole.Syntax.Expr.toString, expr) + " }\n");
  var point = new Vscode.Position(lineNo - 1 | 0, 0);
  var doc = state.editor.document;
  return Editor$Guacamole.insertText(doc, point, assertion);
}

var Spec = {
  fromCursorPosition: fromCursorPosition,
  getPayloadRange: getPayloadRange,
  getPayload: getPayload,
  resolve: resolve,
  insert: insert
};

exports.Config = Config;
exports.setSpecifications = setSpecifications;
exports.onDestroy = onDestroy;
exports.connect = connect;
exports.disconnect = disconnect;
exports.sendRequest = sendRequest;
exports.destroy = destroy;
exports.make = make;
exports.show = show;
exports.hide = hide;
exports.sendRequestToView = sendRequestToView;
exports.display = display;
exports.Spec = Spec;
/* VSCode Not a pure module */
