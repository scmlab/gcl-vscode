// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var VSCode = require("bs-vscode/lib/js/src/VSCode.bs.js");
var Vscode = require("vscode");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var GCL$Guacamole = require("./GCL.bs.js");
var LSP$Guacamole = require("./LSP.bs.js");
var View$Guacamole = require("./View.bs.js");
var Caml_splice_call = require("bs-platform/lib/js/caml_splice_call.js");
var Editor$Guacamole = require("./Util/Editor.bs.js");
var Response$Guacamole = require("./Response.bs.js");

function subscribe(disposable, state) {
  state.subscriptions.push(disposable);
  
}

function displayErrorMessages(msgs) {
  return $$Promise.map(View$Guacamole.send({
                  TAG: 1,
                  _0: msgs,
                  [Symbol.for("name")]: "SetErrorMessages"
                }), (function (param) {
                
              }));
}

function display(id, pos, props) {
  return $$Promise.map(View$Guacamole.send({
                  TAG: 2,
                  _0: id,
                  _1: pos,
                  _2: props,
                  [Symbol.for("name")]: "Display"
                }), (function (param) {
                
              }));
}

function focus(state) {
  Vscode.window.showTextDocument(state.document, /* Beside */1, undefined);
  
}

function sendLSPRequest(state, kind) {
  var source = state.document.getText(undefined);
  return LSP$Guacamole.Client.send({
              _0: state.filePath,
              _1: source,
              _2: kind,
              [Symbol.for("name")]: "Req"
            });
}

function toErrorMessage(error) {
  var kind = error._1;
  if (typeof kind === "number") {
    if (kind === /* LexicalError */0) {
      return [[
                "Lexical Error",
                Curry._1(Response$Guacamole.$$Error.Site.toString, error._0)
              ]];
    } else {
      return [[
                "Client Internal Error",
                "Client not loaded yet"
              ]];
    }
  }
  switch (kind.TAG | 0) {
    case /* SyntacticError */0 :
        return [[
                  "Parse Error",
                  Caml_splice_call.spliceObjApply("\n", "concat", [kind._0])
                ]];
    case /* StructError */1 :
    case /* TypeError */2 :
        return [];
    case /* CannotReadFile */3 :
        return [[
                  "Server Internal Error",
                  "Cannot read file\n" + kind._0
                ]];
    case /* CannotSendRequest */4 :
        return [[
                  "Client Internal Error",
                  "Cannot send request\n" + kind._0
                ]];
    
  }
}

var HandleError = {
  toErrorMessage: toErrorMessage
};

function fromCursorPosition(state) {
  var cursor = state.editor.selection.end;
  var smallestHole = {
    contents: undefined
  };
  Belt_Array.forEach(Belt_Array.keep(state.specifications, (function (spec) {
              var range = GCL$Guacamole.Loc.toRange(spec.loc);
              return range.contains(cursor);
            })), (function (spec) {
          var spec$prime = smallestHole.contents;
          if (spec$prime !== undefined && !GCL$Guacamole.Loc.toRange(spec.loc).contains(GCL$Guacamole.Loc.toRange(spec$prime.loc))) {
            return ;
          } else {
            smallestHole.contents = spec;
            return ;
          }
        }));
  return smallestHole.contents;
}

function getPayloadRange(doc, spec) {
  var range = GCL$Guacamole.Loc.toRange(spec.loc);
  var startingLine = range.start.line + 1 | 0;
  var endingLine = range.end.line - 1 | 0;
  var start = doc.lineAt(startingLine).range.start;
  var end_ = doc.lineAt(endingLine).range.end;
  return new Vscode.Range(start, end_);
}

function getPayload(doc, spec) {
  var innerRange = getPayloadRange(doc, spec);
  return doc.getText(Caml_option.some(innerRange));
}

function resolve(state, i) {
  var specs = Belt_Array.keep(state.specifications, (function (spec) {
          return spec.id === i;
        }));
  Belt_Option.forEach(Belt_Array.get(specs, 0), (function (spec) {
          var payload = getPayload(state.document, spec);
          var range = GCL$Guacamole.Loc.toRange(spec.loc);
          var start = range.start;
          return $$Promise.get($$Promise.flatMap(Editor$Guacamole.$$Text.$$delete(state.document, range), (function (result) {
                            if (result) {
                              return Editor$Guacamole.$$Text.insert(state.document, start, payload.trim());
                            } else {
                              return $$Promise.resolved(false);
                            }
                          })), (function (param) {
                        
                      }));
        }));
  return $$Promise.resolved(undefined);
}

function insert(state, lineNo, expr) {
  var assertion = "{ " + Curry._1(GCL$Guacamole.Syntax.Expr.toString, expr) + " }\n";
  var point = new Vscode.Position(lineNo - 1 | 0, 0);
  return Editor$Guacamole.$$Text.insert(state.document, point, assertion);
}

function decorate(state) {
  Belt_Array.forEach(state.specificationDecorations, (function (prim) {
          prim.dispose();
          
        }));
  var decorations = Belt_Array.concatMany(Belt_Array.map(state.specifications, (function (spec) {
              var range = GCL$Guacamole.Loc.toRange(spec.loc);
              var startPosition = range.start;
              var endPosition = range.end;
              var startRange = new Vscode.Range(startPosition, startPosition.translate(0, 2));
              var endRange = new Vscode.Range(endPosition.translate(0, -2), endPosition);
              var trim = function (s) {
                if (s.length > 77) {
                  return $$String.sub(s, 0, 73) + " ...";
                } else {
                  return s;
                }
              };
              var preCondText = " " + trim(Curry._1(GCL$Guacamole.Syntax.Pred.toString, spec.pre));
              var postCondText = " " + trim(Curry._1(GCL$Guacamole.Syntax.Pred.toString, spec.post));
              var isQQ = preCondText === postCondText;
              var highlightBackground = function (ranges) {
                var backgroundColor = VSCode.StringOr.others(new Vscode.ThemeColor("editor.wordHighlightStrongBackground"));
                var options = {
                  backgroundColor: backgroundColor
                };
                var decoration = Vscode.window.createTextEditorDecorationType(options);
                state.editor.setDecorations(decoration, ranges);
                return decoration;
              };
              var overlayText = function (text, ranges) {
                var color = VSCode.StringOr.others(new Vscode.ThemeColor("descriptionForeground"));
                var after = {
                  color: color,
                  contentText: text
                };
                var options = {
                  after: after
                };
                var decoration = Vscode.window.createTextEditorDecorationType(options);
                state.editor.setDecorations(decoration, ranges);
                return decoration;
              };
              return [
                      overlayText(isQQ ? "" : preCondText, [startRange]),
                      overlayText(postCondText, [endRange]),
                      highlightBackground([
                            startRange,
                            endRange
                          ])
                    ];
            })));
  state.specificationDecorations = decorations;
  
}

var Spec = {
  fromCursorPosition: fromCursorPosition,
  getPayloadRange: getPayloadRange,
  getPayload: getPayload,
  resolve: resolve,
  insert: insert,
  decorate: decorate
};

function handleResponseKind(state, kind) {
  switch (kind.TAG | 0) {
    case /* Error */0 :
        return displayErrorMessages(Belt_Array.concatMany(Belt_Array.map(kind._0, toErrorMessage)));
    case /* OK */1 :
        state.specifications = kind._2;
        decorate(state);
        return display(kind._0, kind._1, kind._3);
    case /* Resolve */2 :
        return $$Promise.map($$Promise.flatMap(resolve(state, kind._0), (function (param) {
                          return state.document.save();
                        })), (function (param) {
                      
                    }));
    case /* Substitute */3 :
        return $$Promise.map(View$Guacamole.send({
                        TAG: 0,
                        _0: kind._0,
                        _1: kind._1,
                        [Symbol.for("name")]: "Substitute"
                      }), (function (param) {
                      
                    }));
    case /* ConsoleLog */4 :
        console.log(kind._0);
        return $$Promise.resolved(undefined);
    
  }
}

var dict = {};

var $$delete = (function (dict, id) {delete dict[id]});

function addBackground(state, key, range, color) {
  var backgroundColor = VSCode.StringOr.others(new Vscode.ThemeColor(color));
  var options = {
    backgroundColor: backgroundColor
  };
  var decoration = Vscode.window.createTextEditorDecorationType(options);
  state.editor.setDecorations(decoration, [range]);
  dict[key] = [decoration];
  
}

function remove(key) {
  Belt_Option.forEach(Js_dict.get(dict, key), (function (decos) {
          return Belt_Array.forEach(decos, (function (prim) {
                        prim.dispose();
                        
                      }));
        }));
  return $$delete(dict, key);
}

function removeAll(param) {
  return Belt_Array.forEach(Js_dict.entries(dict), (function (param) {
                $$delete(dict, param[0]);
                return Belt_Array.forEach(param[1], (function (prim) {
                              prim.dispose();
                              
                            }));
              }));
}

var Decoration = {
  addBackground: addBackground,
  remove: remove,
  removeAll: removeAll
};

function make(editor) {
  var $$document = editor.document;
  var filePath = $$document.fileName;
  return {
          editor: editor,
          document: $$document,
          filePath: filePath,
          specifications: [],
          specificationDecorations: [],
          subscriptions: []
        };
}

function destroy(state) {
  Belt_Array.forEach(state.subscriptions, (function (prim) {
          return prim.dispose();
        }));
  state.subscriptions = [];
  
}

exports.subscribe = subscribe;
exports.displayErrorMessages = displayErrorMessages;
exports.display = display;
exports.focus = focus;
exports.sendLSPRequest = sendLSPRequest;
exports.HandleError = HandleError;
exports.Spec = Spec;
exports.handleResponseKind = handleResponseKind;
exports.Decoration = Decoration;
exports.make = make;
exports.destroy = destroy;
/* VSCode Not a pure module */
