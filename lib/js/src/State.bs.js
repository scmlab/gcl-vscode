// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var VSCode = require("bs-vscode/lib/js/src/VSCode.bs.js");
var Vscode = require("vscode");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var GCL$Guacamole = require("./GCL.bs.js");
var Req$Guacamole = require("./Util/Req.bs.js");
var Chan$Guacamole = require("./Util/Chan.bs.js");
var Util$Guacamole = require("./Util/Util.bs.js");
var Caml_splice_call = require("bs-platform/lib/js/caml_splice_call.js");
var Response$Guacamole = require("./Response.bs.js");

function subscribe(disposable, state) {
  state.subscriptions.push(disposable);
  
}

function display(state, header, body) {
  return $$Promise.map(Req$Guacamole.send(state.viewReq, {
                  TAG: 1,
                  _0: header,
                  _1: body,
                  [Symbol.for("name")]: "Display"
                }), (function (param) {
                
              }));
}

function handleStructError(state, error) {
  switch (error) {
    case /* MissingAssertion */0 :
        return display(state, {
                    TAG: 1,
                    _0: "Assertion Missing",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "Assertion before the DO construct is missing",
                    [Symbol.for("name")]: "Plain"
                  });
    case /* MissingBound */1 :
        return display(state, {
                    TAG: 1,
                    _0: "Bound Missing",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "Bound missing at the end of the assertion before the DO construct \" , bnd : ... }\"",
                    [Symbol.for("name")]: "Plain"
                  });
    case /* ExcessBound */2 :
        return display(state, {
                    TAG: 1,
                    _0: "Excess Bound",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "Unnecessary bound annotation at this assertion",
                    [Symbol.for("name")]: "Plain"
                  });
    case /* MissingPostcondition */3 :
        return display(state, {
                    TAG: 1,
                    _0: "Postcondition Missing",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "The last statement of the program should be an assertion",
                    [Symbol.for("name")]: "Plain"
                  });
    case /* DigHole */4 :
        return $$Promise.resolved(undefined);
    
  }
}

function handleTypeError(state, error) {
  switch (error.TAG | 0) {
    case /* NotInScope */0 :
        return display(state, {
                    TAG: 1,
                    _0: "Type Error",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "The definition " + error._0 + " is not in scope",
                    [Symbol.for("name")]: "Plain"
                  });
    case /* UnifyFailed */1 :
        return display(state, {
                    TAG: 1,
                    _0: "Type Error",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "Cannot unify: " + Curry._1(GCL$Guacamole.Syntax.Type.toString, error._0) + "\nwith        : " + Curry._1(GCL$Guacamole.Syntax.Type.toString, error._1),
                    [Symbol.for("name")]: "Plain"
                  });
    case /* RecursiveType */2 :
        return display(state, {
                    TAG: 1,
                    _0: "Type Error",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "Recursive type variable: " + Curry._1(GCL$Guacamole.Syntax.Type.toString, {
                          TAG: 3,
                          _0: error._0,
                          [Symbol.for("name")]: "Var"
                        }) + "\nin type             : " + Curry._1(GCL$Guacamole.Syntax.Type.toString, error._1),
                    [Symbol.for("name")]: "Plain"
                  });
    case /* NotFunction */3 :
        return display(state, {
                    TAG: 1,
                    _0: "Type Error",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "The type " + Curry._1(GCL$Guacamole.Syntax.Type.toString, error._0) + " is not a function type",
                    [Symbol.for("name")]: "Plain"
                  });
    
  }
}

function handleError(state, error) {
  var kind = error._1;
  if (typeof kind === "number") {
    if (kind === /* LexicalError */0) {
      return display(state, {
                  TAG: 1,
                  _0: "Lexical Error",
                  [Symbol.for("name")]: "Error"
                }, {
                  TAG: 1,
                  _0: Curry._1(Response$Guacamole.$$Error.Site.toString, error._0),
                  [Symbol.for("name")]: "Plain"
                });
    } else {
      return display(state, {
                  TAG: 1,
                  _0: "Client Internal Error",
                  [Symbol.for("name")]: "Error"
                }, {
                  TAG: 1,
                  _0: "Client not loaded yet",
                  [Symbol.for("name")]: "Plain"
                });
    }
  }
  switch (kind.TAG | 0) {
    case /* SyntacticError */0 :
        return display(state, {
                    TAG: 1,
                    _0: "Parse Error",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: Caml_splice_call.spliceObjApply("\n", "concat", [kind._0]),
                    [Symbol.for("name")]: "Plain"
                  });
    case /* StructError */1 :
        return handleStructError(state, kind._0);
    case /* TypeError */2 :
        return handleTypeError(state, kind._0);
    case /* CannotReadFile */3 :
        return display(state, {
                    TAG: 1,
                    _0: "Server Internal Error",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "Cannot read file\n" + kind._0,
                    [Symbol.for("name")]: "Plain"
                  });
    case /* CannotSendRequest */4 :
        return display(state, {
                    TAG: 1,
                    _0: "Client Internal Error",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "Cannot send request\n" + kind._0,
                    [Symbol.for("name")]: "Plain"
                  });
    
  }
}

function handleResponseKind(state, kind) {
  switch (kind.TAG | 0) {
    case /* Decorate */0 :
        Belt_Array.forEach(state.decorations, (function (prim) {
                prim.dispose();
                
              }));
        state.decorations = [];
        var ranges = Belt_Array.map(kind._0, GCL$Guacamole.Loc.toRange);
        var rangeBehavior = VSCode.DecorationRangeBehavior.toEnum(/* ClosedClosed */1);
        var rulerColor = VSCode.StringOr.others(new Vscode.ThemeColor("editorOverviewRuler.warningForeground"));
        var overviewRulerLane = VSCode.OverviewRulerLane.toEnum(/* Left */0);
        var backgroundColor = VSCode.StringOr.others(new Vscode.ThemeColor("editorOverviewRuler.warningForeground"));
        var after = {
          color: backgroundColor,
          contentText: "*"
        };
        var options = {
          after: after,
          overviewRulerColor: rulerColor,
          overviewRulerLane: overviewRulerLane,
          rangeBehavior: rangeBehavior
        };
        var decoration = Vscode.window.createTextEditorDecorationType(options);
        state.decorations.push(decoration);
        state.editor.setDecorations(decoration, ranges);
        return $$Promise.resolved(undefined);
    case /* Error */1 :
        return $$Promise.map(Util$Guacamole.$$Promise.oneByOne(Belt_Array.map(kind._0, (function (param) {
                              return handleError(state, param);
                            }))), (function (param) {
                      
                    }));
    case /* OK */2 :
        return display(state, {
                    TAG: 0,
                    _0: "Proof Obligations",
                    [Symbol.for("name")]: "Plain"
                  }, {
                    TAG: 0,
                    _0: kind._0,
                    _1: kind._1,
                    _2: kind._3,
                    [Symbol.for("name")]: "ProofObligations"
                  });
    default:
      return $$Promise.resolved(undefined);
  }
}

function make(editor) {
  var $$document = editor.document;
  var filePath = $$document.fileName;
  return {
          editor: editor,
          document: $$document,
          filePath: filePath,
          viewReq: Req$Guacamole.make(undefined),
          viewResChan: Chan$Guacamole.make(undefined),
          decorations: [],
          subscriptions: []
        };
}

function destroy(state) {
  Belt_Array.forEach(state.decorations, (function (prim) {
          prim.dispose();
          
        }));
  state.decorations = [];
  Belt_Array.forEach(state.subscriptions, (function (prim) {
          return prim.dispose();
        }));
  state.subscriptions = [];
  
}

exports.subscribe = subscribe;
exports.display = display;
exports.handleStructError = handleStructError;
exports.handleTypeError = handleTypeError;
exports.handleError = handleError;
exports.handleResponseKind = handleResponseKind;
exports.make = make;
exports.destroy = destroy;
/* VSCode Not a pure module */
