// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var VSCode = require("bs-vscode/lib/js/src/VSCode.bs.js");
var Vscode = require("vscode");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var GCL$Guacamole = require("./GCL.bs.js");
var Util$Guacamole = require("./Util/Util.bs.js");
var Editor$Guacamole = require("./Util/Editor.bs.js");
var Response$Guacamole = require("./Response.bs.js");

function subscribe(disposable, state) {
  state.subscriptions.push(disposable);
  
}

function display(state, header, body) {
  return $$Promise.map(Curry._1(state.viewSendRequest, {
                  TAG: 1,
                  _0: header,
                  _1: body,
                  [Symbol.for("name")]: "Display"
                }), (function (param) {
                
              }));
}

function focus(state) {
  Vscode.window.showTextDocument(state.document, /* Beside */1, undefined);
  
}

function handleStructError(state, site, error) {
  switch (error) {
    case /* MissingAssertion */0 :
        return display(state, {
                    TAG: 1,
                    _0: "Assertion Missing",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "Assertion before the DO construct is missing",
                    [Symbol.for("name")]: "Plain"
                  });
    case /* MissingBound */1 :
        return display(state, {
                    TAG: 1,
                    _0: "Bound Missing",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "Bound missing at the end of the assertion before the DO construct \" , bnd : ... }\"",
                    [Symbol.for("name")]: "Plain"
                  });
    case /* ExcessBound */2 :
        return display(state, {
                    TAG: 1,
                    _0: "Excess Bound",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "Unnecessary bound annotation at this assertion",
                    [Symbol.for("name")]: "Plain"
                  });
    case /* MissingPostcondition */3 :
        return display(state, {
                    TAG: 1,
                    _0: "Postcondition Missing",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "The last statement of the program should be an assertion",
                    [Symbol.for("name")]: "Plain"
                  });
    case /* DigHole */4 :
        var range = Curry._3(Response$Guacamole.$$Error.Site.toRange, site, state.specifications, GCL$Guacamole.Loc.toRange);
        var indent = " ".repeat(range.start.character);
        var holeText = "{!\n" + indent + "\n" + indent + "!}";
        var holeRange = new Vscode.Range(range.start, range.start.translate(0, 1));
        return $$Promise.map($$Promise.flatMap($$Promise.map(Editor$Guacamole.$$Text.replace(state.document, holeRange, holeText), (function (param) {
                              var selectionRange = new Vscode.Range(range.start.translate(1, 0), range.start.translate(1, 0));
                              return Editor$Guacamole.$$Selection.set(state.editor, selectionRange);
                            })), (function (param) {
                          return state.document.save();
                        })), (function (param) {
                      
                    }));
    
  }
}

function handleTypeError(state, error) {
  switch (error.TAG | 0) {
    case /* NotInScope */0 :
        return display(state, {
                    TAG: 1,
                    _0: "Type Error",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "The definition " + error._0 + " is not in scope",
                    [Symbol.for("name")]: "Plain"
                  });
    case /* UnifyFailed */1 :
        return display(state, {
                    TAG: 1,
                    _0: "Type Error",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "Cannot unify: " + Curry._1(GCL$Guacamole.Syntax.Type.toString, error._0) + "\nwith        : " + Curry._1(GCL$Guacamole.Syntax.Type.toString, error._1),
                    [Symbol.for("name")]: "Plain"
                  });
    case /* RecursiveType */2 :
        return display(state, {
                    TAG: 1,
                    _0: "Type Error",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "Recursive type variable: " + Curry._1(GCL$Guacamole.Syntax.Type.toString, {
                          TAG: 3,
                          _0: error._0,
                          [Symbol.for("name")]: "Var"
                        }) + "\nin type             : " + Curry._1(GCL$Guacamole.Syntax.Type.toString, error._1),
                    [Symbol.for("name")]: "Plain"
                  });
    case /* NotFunction */3 :
        return display(state, {
                    TAG: 1,
                    _0: "Type Error",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "The type " + Curry._1(GCL$Guacamole.Syntax.Type.toString, error._0) + " is not a function type",
                    [Symbol.for("name")]: "Plain"
                  });
    
  }
}

function handleError(state, error) {
  var kind = error._1;
  if (typeof kind === "number") {
    if (kind === /* NotLoaded */1) {
      return display(state, {
                  TAG: 1,
                  _0: "Client Internal Error",
                  [Symbol.for("name")]: "Error"
                }, {
                  TAG: 1,
                  _0: "Client not loaded yet",
                  [Symbol.for("name")]: "Plain"
                });
    } else {
      return $$Promise.resolved(undefined);
    }
  }
  switch (kind.TAG | 0) {
    case /* StructError */1 :
        return handleStructError(state, error._0, kind._0);
    case /* CannotReadFile */3 :
        return display(state, {
                    TAG: 1,
                    _0: "Server Internal Error",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "Cannot read file\n" + kind._0,
                    [Symbol.for("name")]: "Plain"
                  });
    case /* CannotSendRequest */4 :
        return display(state, {
                    TAG: 1,
                    _0: "Client Internal Error",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "Cannot send request\n" + kind._0,
                    [Symbol.for("name")]: "Plain"
                  });
    default:
      return $$Promise.resolved(undefined);
  }
}

function fromCursorPosition(state) {
  var cursor = state.editor.selection.end;
  var smallestHole = {
    contents: undefined
  };
  Belt_Array.forEach(Belt_Array.keep(state.specifications, (function (spec) {
              var range = GCL$Guacamole.Loc.toRange(spec.loc);
              return range.contains(cursor);
            })), (function (spec) {
          var spec$prime = smallestHole.contents;
          if (spec$prime !== undefined && !GCL$Guacamole.Loc.toRange(spec.loc).contains(GCL$Guacamole.Loc.toRange(spec$prime.loc))) {
            return ;
          } else {
            smallestHole.contents = spec;
            return ;
          }
        }));
  return smallestHole.contents;
}

function getPayloadRange(doc, spec) {
  var range = GCL$Guacamole.Loc.toRange(spec.loc);
  var startingLine = range.start.line + 1 | 0;
  var endingLine = range.end.line - 1 | 0;
  var start = doc.lineAt(startingLine).range.start;
  var end_ = doc.lineAt(endingLine).range.end;
  return new Vscode.Range(start, end_);
}

function getPayload(doc, spec) {
  var innerRange = getPayloadRange(doc, spec);
  return doc.getText(Caml_option.some(innerRange));
}

function resolve(state, i) {
  var specs = Belt_Array.keep(state.specifications, (function (spec) {
          return spec.id === i;
        }));
  Belt_Option.forEach(Belt_Array.get(specs, 0), (function (spec) {
          var payload = getPayload(state.document, spec);
          var range = GCL$Guacamole.Loc.toRange(spec.loc);
          var start = range.start;
          return $$Promise.get($$Promise.flatMap(Editor$Guacamole.$$Text.$$delete(state.document, range), (function (result) {
                            if (result) {
                              return Editor$Guacamole.$$Text.insert(state.document, start, payload.trim());
                            } else {
                              return $$Promise.resolved(false);
                            }
                          })), (function (param) {
                        
                      }));
        }));
  return $$Promise.resolved(undefined);
}

function insert(state, lineNo, expr) {
  var assertion = "{ " + Curry._1(GCL$Guacamole.Syntax.Expr.toString, expr) + " }\n";
  var point = new Vscode.Position(lineNo - 1 | 0, 0);
  return Editor$Guacamole.$$Text.insert(state.document, point, assertion);
}

var Spec = {
  fromCursorPosition: fromCursorPosition,
  getPayloadRange: getPayloadRange,
  getPayload: getPayload,
  resolve: resolve,
  insert: insert
};

function handleResponseKind(state, kind) {
  switch (kind.TAG | 0) {
    case /* Error */0 :
        return $$Promise.map(Util$Guacamole.$$Promise.oneByOne(Belt_Array.map(kind._0, (function (param) {
                              return handleError(state, param);
                            }))), (function (param) {
                      
                    }));
    case /* OK */1 :
        state.specifications = kind._2;
        return display(state, {
                    TAG: 0,
                    _0: "Proof Obligations",
                    [Symbol.for("name")]: "Plain"
                  }, {
                    TAG: 0,
                    _0: kind._0,
                    _1: kind._1,
                    _2: kind._3,
                    [Symbol.for("name")]: "ProofObligations"
                  });
    case /* Resolve */2 :
        return $$Promise.resolved(undefined);
    case /* Substitute */3 :
        return $$Promise.map(Curry._1(state.viewSendRequest, {
                        TAG: 0,
                        _0: kind._0,
                        _1: kind._1,
                        [Symbol.for("name")]: "Substitute"
                      }), (function (param) {
                      
                    }));
    
  }
}

function handleResponseWithState(state, response) {
  switch (response.TAG | 0) {
    case /* Res */0 :
        return $$Promise.map(Util$Guacamole.$$Promise.oneByOne(Belt_Array.map(response._1, (function (param) {
                              return handleResponseKind(state, param);
                            }))), (function (param) {
                      
                    }));
    case /* CannotDecodeResponse */1 :
        console.error("Client Internal Error\nCannot decode response from the server\n" + response._0, response._1);
        return $$Promise.resolved(undefined);
    case /* CannotDecodeRequest */2 :
        console.error("Server Internal Error\nCannot decode request from the client\n" + response._0);
        return $$Promise.resolved(undefined);
    case /* CannotSendRequest */3 :
        console.error("Client Internal Error\nCannot send request to the server\n" + response._0);
        return $$Promise.resolved(undefined);
    
  }
}

var dict = {};

var $$delete = (function (dict, id) {delete dict[id]});

function addBackground(state, key, range, color) {
  var backgroundColor = VSCode.StringOr.others(new Vscode.ThemeColor(color));
  var options = {
    backgroundColor: backgroundColor
  };
  var decoration = Vscode.window.createTextEditorDecorationType(options);
  state.editor.setDecorations(decoration, [range]);
  dict[key] = [decoration];
  
}

function remove(key) {
  Belt_Option.forEach(Js_dict.get(dict, key), (function (decos) {
          return Belt_Array.forEach(decos, (function (prim) {
                        prim.dispose();
                        
                      }));
        }));
  return $$delete(dict, key);
}

function removeAll(param) {
  return Belt_Array.forEach(Js_dict.entries(dict), (function (param) {
                $$delete(dict, param[0]);
                return Belt_Array.forEach(param[1], (function (prim) {
                              prim.dispose();
                              
                            }));
              }));
}

var Decoration = {
  addBackground: addBackground,
  remove: remove,
  removeAll: removeAll
};

function make(editor, viewSendRequest, viewOnResponse, lspSendRequest) {
  var $$document = editor.document;
  var filePath = $$document.fileName;
  var state = {
    editor: editor,
    document: $$document,
    filePath: filePath,
    viewSendRequest: viewSendRequest,
    viewOnResponse: viewOnResponse,
    lspSendRequest: lspSendRequest,
    specifications: [],
    subscriptions: []
  };
  state.subscriptions.push(new Vscode.Disposable(Curry._1(viewOnResponse, (function (response) {
                  if (typeof response === "number") {
                    return ;
                  }
                  if (response.TAG) {
                    removeAll(undefined);
                    $$Promise.flatMap(Curry._1(lspSendRequest, {
                              _0: state.filePath,
                              _1: {
                                TAG: 2,
                                _0: response._0,
                                _1: response._1,
                                _2: response._2,
                                [Symbol.for("name")]: "Substitute"
                              },
                              [Symbol.for("name")]: "Req"
                            }), (function (param) {
                            return handleResponseWithState(state, param);
                          }));
                    return ;
                  }
                  var loc = response._0;
                  switch (loc.TAG | 0) {
                    case /* MouseOver */0 :
                        var loc$1 = loc._0;
                        var key = GCL$Guacamole.Loc.toString(loc$1);
                        var range = GCL$Guacamole.Loc.toRange(loc$1);
                        return addBackground(state, key, range, "statusBar.debuggingBackground");
                    case /* MouseOut */1 :
                        return remove(GCL$Guacamole.Loc.toString(loc._0));
                    case /* MouseClick */2 :
                        return ;
                    
                  }
                }))));
  return state;
}

function destroy(state) {
  Belt_Array.forEach(state.subscriptions, (function (prim) {
          return prim.dispose();
        }));
  state.subscriptions = [];
  
}

exports.subscribe = subscribe;
exports.display = display;
exports.focus = focus;
exports.handleStructError = handleStructError;
exports.handleTypeError = handleTypeError;
exports.handleError = handleError;
exports.Spec = Spec;
exports.handleResponseKind = handleResponseKind;
exports.handleResponseWithState = handleResponseWithState;
exports.Decoration = Decoration;
exports.make = make;
exports.destroy = destroy;
/* VSCode Not a pure module */
