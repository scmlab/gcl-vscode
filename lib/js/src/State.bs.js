// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var VSCode = require("bs-vscode/lib/js/src/VSCode.bs.js");
var Vscode = require("vscode");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var GCL$Guacamole = require("./GCL.bs.js");
var View$Guacamole = require("./View.bs.js");
var Request$Guacamole = require("./Request.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var Response$Guacamole = require("./Response.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Event$AgdaModeVscode = require("agda-mode-vscode/lib/js/src/Util/Event.bs.js");
var Editor$AgdaModeVscode = require("agda-mode-vscode/lib/js/src/Editor.bs.js");

function setGCLPath(path) {
  return Vscode.workspace.getConfiguration("guacamole", undefined).update("gclPath", path, 1, undefined);
}

function getGCLPath(param) {
  return Vscode.workspace.getConfiguration("guacamole", undefined).get("gclPath");
}

var Config = {
  setGCLPath: setGCLPath,
  getGCLPath: getGCLPath
};

function setSpecifications(state, specifications) {
  state.specifications = specifications;
  
}

function onDestroy(state, callback) {
  return new Vscode.Disposable(Curry._1(state.onDestroyEventEmitter.on, callback));
}

function sendRequest(state, request) {
  var value = Request$Guacamole.encode(request);
  console.log("<<<", value);
  return $$Promise.flatMap($$Promise.flatMap(state.client.onReady(), (function (param) {
                    return state.client.sendRequest("guacamole", value);
                  })), (function (result) {
                console.log(">>>", JSON.stringify(result).substring(0, 200));
                var value;
                try {
                  value = Response$Guacamole.decode(result);
                }
                catch (raw_msg){
                  var msg = Caml_js_exceptions.internalToOCamlException(raw_msg);
                  if (msg[0] === Json_decode.DecodeError) {
                    return $$Promise.resolved(/* Error */Caml_chrome_debugger.variant("Error", 1, [/* Decode */Caml_chrome_debugger.simpleVariant("Decode", [
                                      msg[1],
                                      result
                                    ])]));
                  }
                  throw msg;
                }
                return $$Promise.resolved(/* Ok */Caml_chrome_debugger.variant("Ok", 0, [value]));
              }));
}

function destroy(state) {
  View$Guacamole.destroy(state.view);
  Curry._1(state.onDestroyEventEmitter.emit, undefined);
  Curry._1(state.onDestroyEventEmitter.destroy, undefined);
  Belt_Array.forEach(state.decorations, Editor$AgdaModeVscode.Decoration.destroy);
  Belt_Array.forEach(state.disposables, (function (prim) {
          return prim.dispose();
        }));
  state.client.stop();
  
}

var Command = { };

var FoldingContext = { };

var FoldingRangeKind = { };

function makeWithKind(start, end_, kind) {
  switch (kind) {
    case /* Comment */0 :
        return new Vscode.FoldingRange(start, end_, 1);
    case /* Imports */1 :
        return new Vscode.FoldingRange(start, end_, 2);
    case /* Region */2 :
        return new Vscode.FoldingRange(start, end_, 3);
    
  }
}

var FoldingRange = {
  makeWithKind: makeWithKind
};

var FoldingRangeProvider = { };

function make(extentionPath, editor, client) {
  var disposables = [];
  client.start();
  var view = View$Guacamole.make(extentionPath, editor);
  var docSelector = [VSCode.DocumentFilterOrString.documentFilter({
          language: "gcl",
          pattern: undefined,
          scheme: undefined
        })];
  var foldingRangeProvider = {
    provideFoldingRanges: (function (param, param$1, param$2) {
        var foldingRanges = [new Vscode.FoldingRange(3, 5, 3)];
        return Caml_option.some($$Promise.resolved(foldingRanges));
      })
  };
  disposables.push(Vscode.languages.registerFoldingRangeProvider(docSelector, foldingRangeProvider));
  return {
          editor: editor,
          view: view,
          mode: /* WP1 */0,
          decorations: [],
          specifications: [],
          client: client,
          onDestroyEventEmitter: Event$AgdaModeVscode.make(undefined),
          disposables: disposables
        };
}

function show(state) {
  return View$Guacamole.show(state.view);
}

function hide(state) {
  return View$Guacamole.hide(state.view);
}

function sendRequestToView(state, request) {
  return View$Guacamole.send(state.view, request);
}

function display(state, header, body) {
  return View$Guacamole.send(state.view, /* Display */Caml_chrome_debugger.variant("Display", 1, [
                header,
                body
              ]));
}

function fromCursorPosition(state) {
  var cursor = state.editor.selection.end;
  var smallestHole = {
    contents: undefined
  };
  Belt_Array.forEach(Belt_Array.keep(state.specifications, (function (spec) {
              var range = GCL$Guacamole.Loc.toRange(spec.loc);
              return range.contains(cursor);
            })), (function (spec) {
          var spec$prime = smallestHole.contents;
          if (spec$prime !== undefined && !GCL$Guacamole.Loc.toRange(spec.loc).contains(GCL$Guacamole.Loc.toRange(spec$prime.loc))) {
            return ;
          } else {
            smallestHole.contents = spec;
            return ;
          }
        }));
  return smallestHole.contents;
}

function getPayloadRange(doc, spec) {
  var range = GCL$Guacamole.Loc.toRange(spec.loc);
  var startingLine = range.start.line + 1 | 0;
  var endingLine = range.end.line - 1 | 0;
  var start = doc.lineAt(startingLine).range.start;
  var end_ = doc.lineAt(endingLine).range.end;
  return new Vscode.Range(start, end_);
}

function getPayload(doc, spec) {
  var innerRange = getPayloadRange(doc, spec);
  return doc.getText(Caml_option.some(innerRange));
}

function resolve(state, i) {
  var specs = Belt_Array.keep(state.specifications, (function (spec) {
          return spec.id === i;
        }));
  Belt_Option.forEach(Belt_Array.get(specs, 0), (function (spec) {
          var doc = state.editor.document;
          var payload = getPayload(doc, spec);
          var range = GCL$Guacamole.Loc.toRange(spec.loc);
          var start = range.start;
          return $$Promise.get($$Promise.flatMap(Editor$AgdaModeVscode.$$Text.$$delete(doc, range), (function (param) {
                            if (param) {
                              return Editor$AgdaModeVscode.$$Text.insert(doc, start, payload.trim());
                            } else {
                              return $$Promise.resolved(false);
                            }
                          })), (function (param) {
                        
                      }));
        }));
  return $$Promise.resolved(undefined);
}

function insert(state, lineNo, expr) {
  var assertion = "{ " + (Curry._1(GCL$Guacamole.Syntax.Expr.toString, expr) + " }\n");
  var point = new Vscode.Position(lineNo - 1 | 0, 0);
  var doc = state.editor.document;
  return Editor$AgdaModeVscode.$$Text.insert(doc, point, assertion);
}

var Spec = {
  fromCursorPosition: fromCursorPosition,
  getPayloadRange: getPayloadRange,
  getPayload: getPayload,
  resolve: resolve,
  insert: insert
};

var VSRange;

exports.VSRange = VSRange;
exports.Config = Config;
exports.setSpecifications = setSpecifications;
exports.onDestroy = onDestroy;
exports.sendRequest = sendRequest;
exports.destroy = destroy;
exports.Command = Command;
exports.FoldingContext = FoldingContext;
exports.FoldingRangeKind = FoldingRangeKind;
exports.FoldingRange = FoldingRange;
exports.FoldingRangeProvider = FoldingRangeProvider;
exports.make = make;
exports.show = show;
exports.hide = hide;
exports.sendRequestToView = sendRequestToView;
exports.display = display;
exports.Spec = Spec;
/* VSCode Not a pure module */
