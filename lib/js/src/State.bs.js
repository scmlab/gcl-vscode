// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var Ok$Guacamole = require("./Util/Ok.bs.js");
var GCL$Guacamole = require("./GCL.bs.js");
var Event$Guacamole = require("./Util/Event.bs.js");
var Request$Guacamole = require("./Request.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var Response$Guacamole = require("./Response.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Connection$Guacamole = require("./Connection.bs.js");

function Impl(Editor) {
  var getEditor = function (state) {
    return state.editor;
  };
  var setSpecifications = function (state, specifications) {
    state.specifications = specifications;
    return /* () */0;
  };
  var onDestroy = function (state, callback) {
    return Curry._1(Editor.Disposable.make, Curry._1(state.onDestroyEventEmitter.on, callback));
  };
  var connect = function (state) {
    var match = state.connection;
    if (match !== undefined) {
      return $$Promise.resolved(/* Ok */Caml_chrome_debugger.variant("Ok", 0, [match]));
    } else {
      return $$Promise.tapOk($$Promise.mapError(Connection$Guacamole.make(Editor.Config.getGCLPath, Editor.Config.setGCLPath), (function (e) {
                        return /* Connection */Caml_chrome_debugger.variant("Connection", 0, [e]);
                      })), (function (conn) {
                    state.connection = conn;
                    return /* () */0;
                  }));
    }
  };
  var disconnect = function (state) {
    var match = state.connection;
    if (match !== undefined) {
      return Connection$Guacamole.disconnect(match);
    } else {
      return $$Promise.resolved(/* () */0);
    }
  };
  var sendRequest = function (state, request) {
    var value = Request$Guacamole.encode(request);
    console.log("<<<", value);
    return Ok$Guacamole.let_(connect(state), (function (conn) {
                  return Ok$Guacamole.let_($$Promise.mapError(Connection$Guacamole.send(value, conn), (function (e) {
                                    return /* Connection */Caml_chrome_debugger.variant("Connection", 0, [e]);
                                  })), (function (result) {
                                console.log(">>>", JSON.stringify(result).substring(0, 200));
                                var val;
                                try {
                                  val = Json_decode.pair(Json_decode.$$int, Response$Guacamole.decode, result);
                                }
                                catch (raw_exn){
                                  var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                                  if (exn[0] === Json_decode.DecodeError) {
                                    return $$Promise.resolved(/* Error */Caml_chrome_debugger.variant("Error", 1, [/* Decode */Caml_chrome_debugger.variant("Decode", 1, [
                                                      exn[1],
                                                      result
                                                    ])]));
                                  } else {
                                    throw exn;
                                  }
                                }
                                return $$Promise.resolved(/* Ok */Caml_chrome_debugger.variant("Ok", 0, [/* tuple */[
                                                val[0],
                                                val[1]
                                              ]]));
                              }));
                }));
  };
  var destroy = function (state) {
    Curry._1(Editor.View.destroy, state.view);
    Curry._1(state.onDestroyEventEmitter.destroy, /* () */0);
    Curry._1(state.onDestroyEventEmitter.emit, /* () */0);
    Belt_Array.forEach(state.decorations, Editor.Decoration.destroy);
    return disconnect(state);
  };
  var make = function (context, editor) {
    var view = Curry._2(Editor.View.make, context, editor);
    return {
            editor: editor,
            context: context,
            view: view,
            mode: /* WP1 */0,
            decorations: [],
            specifications: [],
            connection: undefined,
            onDestroyEventEmitter: Event$Guacamole.make(/* () */0)
          };
  };
  var show = function (state) {
    return Curry._1(Editor.View.show, state.view);
  };
  var hide = function (state) {
    return Curry._1(Editor.View.hide, state.view);
  };
  var sendRequestToView = function (state, id, request) {
    return Curry._3(Editor.View.send, state.view, id, request);
  };
  var display = function (state, id, header, body) {
    return sendRequestToView(state, id, /* Display */Caml_chrome_debugger.variant("Display", 1, [
                  header,
                  body
                ]));
  };
  var fromCursorPosition = function (state) {
    var cursor = Curry._1(Editor.getCursorPosition, state.editor);
    var smallestHole = {
      contents: undefined
    };
    Belt_Array.forEach(Belt_Array.keep(state.specifications, (function (spec) {
                var range = Curry._1(Editor.$$Range.fromLoc, spec.loc);
                return Curry._2(Editor.$$Range.contains, range, cursor);
              })), (function (spec) {
            var match = smallestHole.contents;
            if (match !== undefined && !Curry._2(Editor.$$Range.containsRange, Curry._1(Editor.$$Range.fromLoc, spec.loc), Curry._1(Editor.$$Range.fromLoc, match.loc))) {
              return 0;
            } else {
              smallestHole.contents = spec;
              return /* () */0;
            }
          }));
    return smallestHole.contents;
  };
  var getPayloadRange = function (editor, spec) {
    var range = Curry._1(Editor.$$Range.fromLoc, spec.loc);
    var startingLine = Curry._1(Editor.Point.line, Curry._1(Editor.$$Range.start, range)) + 1 | 0;
    var endingLine = Curry._1(Editor.Point.line, Curry._1(Editor.$$Range.end_, range)) - 1 | 0;
    var start = Curry._1(Editor.$$Range.start, Curry._2(Editor.rangeForLine, editor, startingLine));
    var end_ = Curry._1(Editor.$$Range.end_, Curry._2(Editor.rangeForLine, editor, endingLine));
    return Curry._2(Editor.$$Range.make, start, end_);
  };
  var getPayload = function (editor, spec) {
    var innerRange = getPayloadRange(editor, spec);
    return Curry._2(Editor.getText, editor, innerRange);
  };
  var resolve = function (state, i) {
    var specs = Belt_Array.keep(state.specifications, (function (spec) {
            return spec.id === i;
          }));
    Belt_Option.forEach(Belt_Array.get(specs, 0), (function (spec) {
            var payload = getPayload(state.editor, spec);
            var range = Curry._1(Editor.$$Range.fromLoc, spec.loc);
            var start = Curry._1(Editor.$$Range.start, range);
            return $$Promise.get($$Promise.flatMap(Curry._2(Editor.deleteText, state.editor, range), (function (param) {
                              if (param) {
                                return Curry._3(Editor.insertText, state.editor, start, payload.trim());
                              } else {
                                return $$Promise.resolved(false);
                              }
                            })), (function (param) {
                          return /* () */0;
                        }));
          }));
    return $$Promise.resolved(/* () */0);
  };
  var insert = function (state, lineNo, expr) {
    var assertion = "{ " + (Curry._1(GCL$Guacamole.Syntax.Expr.toString, expr) + " }\n");
    var point = Curry._2(Editor.Point.make, lineNo - 1 | 0, 0);
    return Curry._3(Editor.insertText, state.editor, point, assertion);
  };
  var Spec = {
    fromCursorPosition: fromCursorPosition,
    getPayloadRange: getPayloadRange,
    getPayload: getPayload,
    resolve: resolve,
    insert: insert
  };
  return {
          getEditor: getEditor,
          setSpecifications: setSpecifications,
          onDestroy: onDestroy,
          connect: connect,
          disconnect: disconnect,
          sendRequest: sendRequest,
          destroy: destroy,
          make: make,
          show: show,
          hide: hide,
          sendRequestToView: sendRequestToView,
          display: display,
          Spec: Spec
        };
}

exports.Impl = Impl;
/* Promise Not a pure module */
