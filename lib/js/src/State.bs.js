// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var VSCode = require("bs-vscode/lib/js/src/VSCode.bs.js");
var Vscode = require("vscode");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var GCL$Guacamole = require("./GCL.bs.js");
var Req$Guacamole = require("./Util/Req.bs.js");
var Chan$Guacamole = require("./Util/Chan.bs.js");
var Util$Guacamole = require("./Util/Util.bs.js");

function subscribe(disposable, state) {
  state.subscriptions.push(disposable);
  
}

function display(state, header, body) {
  return $$Promise.map(Req$Guacamole.send(state.viewReq, {
                  TAG: 1,
                  _0: header,
                  _1: body,
                  [Symbol.for("name")]: "Display"
                }), (function (param) {
                
              }));
}

function handleStructError(state, error) {
  switch (error) {
    case /* MissingAssertion */0 :
        return display(state, {
                    TAG: 1,
                    _0: "Assertion Missing",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "Assertion before the DO construct is missing",
                    [Symbol.for("name")]: "Plain"
                  });
    case /* MissingBound */1 :
        return display(state, {
                    TAG: 1,
                    _0: "Bound Missing",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "Bound missing at the end of the assertion before the DO construct \" , bnd : ... }\"",
                    [Symbol.for("name")]: "Plain"
                  });
    case /* ExcessBound */2 :
        return display(state, {
                    TAG: 1,
                    _0: "Excess Bound",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "Unnecessary bound annotation at this assertion",
                    [Symbol.for("name")]: "Plain"
                  });
    case /* MissingPostcondition */3 :
        return display(state, {
                    TAG: 1,
                    _0: "Postcondition Missing",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "The last statement of the program should be an assertion",
                    [Symbol.for("name")]: "Plain"
                  });
    case /* DigHole */4 :
        return $$Promise.resolved(undefined);
    
  }
}

function handleTypeError(state, error) {
  switch (error.TAG | 0) {
    case /* NotInScope */0 :
        return display(state, {
                    TAG: 1,
                    _0: "Type Error",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "The definition " + error._0 + " is not in scope",
                    [Symbol.for("name")]: "Plain"
                  });
    case /* UnifyFailed */1 :
        return display(state, {
                    TAG: 1,
                    _0: "Type Error",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "Cannot unify: " + Curry._1(GCL$Guacamole.Syntax.Type.toString, error._0) + "\nwith        : " + Curry._1(GCL$Guacamole.Syntax.Type.toString, error._1),
                    [Symbol.for("name")]: "Plain"
                  });
    case /* RecursiveType */2 :
        return display(state, {
                    TAG: 1,
                    _0: "Type Error",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "Recursive type variable: " + Curry._1(GCL$Guacamole.Syntax.Type.toString, {
                          TAG: 3,
                          _0: error._0,
                          [Symbol.for("name")]: "Var"
                        }) + "\nin type             : " + Curry._1(GCL$Guacamole.Syntax.Type.toString, error._1),
                    [Symbol.for("name")]: "Plain"
                  });
    case /* NotFunction */3 :
        return display(state, {
                    TAG: 1,
                    _0: "Type Error",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "The type " + Curry._1(GCL$Guacamole.Syntax.Type.toString, error._0) + " is not a function type",
                    [Symbol.for("name")]: "Plain"
                  });
    
  }
}

function handleError(state, error) {
  var kind = error._1;
  if (typeof kind === "number") {
    if (kind === /* NotLoaded */1) {
      return display(state, {
                  TAG: 1,
                  _0: "Client Internal Error",
                  [Symbol.for("name")]: "Error"
                }, {
                  TAG: 1,
                  _0: "Client not loaded yet",
                  [Symbol.for("name")]: "Plain"
                });
    } else {
      return $$Promise.resolved(undefined);
    }
  }
  switch (kind.TAG | 0) {
    case /* CannotReadFile */3 :
        return display(state, {
                    TAG: 1,
                    _0: "Server Internal Error",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "Cannot read file\n" + kind._0,
                    [Symbol.for("name")]: "Plain"
                  });
    case /* CannotSendRequest */4 :
        return display(state, {
                    TAG: 1,
                    _0: "Client Internal Error",
                    [Symbol.for("name")]: "Error"
                  }, {
                    TAG: 1,
                    _0: "Cannot send request\n" + kind._0,
                    [Symbol.for("name")]: "Plain"
                  });
    default:
      return $$Promise.resolved(undefined);
  }
}

function handleResponseKind(state, kind) {
  switch (kind.TAG | 0) {
    case /* Decorate */0 :
        return $$Promise.resolved(undefined);
    case /* Error */1 :
        return $$Promise.map(Util$Guacamole.$$Promise.oneByOne(Belt_Array.map(kind._0, (function (param) {
                              return handleError(state, param);
                            }))), (function (param) {
                      
                    }));
    case /* OK */2 :
        return display(state, {
                    TAG: 0,
                    _0: "Proof Obligations",
                    [Symbol.for("name")]: "Plain"
                  }, {
                    TAG: 0,
                    _0: kind._0,
                    _1: kind._1,
                    _2: kind._3,
                    [Symbol.for("name")]: "ProofObligations"
                  });
    default:
      return $$Promise.resolved(undefined);
  }
}

var dict = {};

var $$delete = (function (dict, id) {delete dict[id]});

function addBackground(state, key, range, color) {
  var backgroundColor = VSCode.StringOr.others(new Vscode.ThemeColor(color));
  var options = {
    backgroundColor: backgroundColor
  };
  var decoration = Vscode.window.createTextEditorDecorationType(options);
  state.editor.setDecorations(decoration, [range]);
  dict[key] = [decoration];
  
}

function remove(key) {
  Belt_Option.forEach(Js_dict.get(dict, key), (function (decos) {
          return Belt_Array.forEach(decos, (function (prim) {
                        prim.dispose();
                        
                      }));
        }));
  return $$delete(dict, key);
}

function removeAll(param) {
  return Belt_Array.forEach(Js_dict.entries(dict), (function (param) {
                $$delete(dict, param[0]);
                return Belt_Array.forEach(param[1], (function (prim) {
                              prim.dispose();
                              
                            }));
              }));
}

var Decoration = {
  dict: dict,
  $$delete: $$delete,
  addBackground: addBackground,
  remove: remove,
  removeAll: removeAll
};

function make(editor) {
  var $$document = editor.document;
  var filePath = $$document.fileName;
  var state = {
    editor: editor,
    document: $$document,
    filePath: filePath,
    viewReq: Req$Guacamole.make(undefined),
    viewResChan: Chan$Guacamole.make(undefined),
    subscriptions: []
  };
  state.subscriptions.push(new Vscode.Disposable(Chan$Guacamole.on(state.viewResChan, (function (response) {
                  if (typeof response === "number") {
                    console.log(response);
                    return ;
                  }
                  if (response.TAG) {
                    console.log(response);
                    return ;
                  }
                  var loc = response._0;
                  switch (loc.TAG | 0) {
                    case /* MouseOver */0 :
                        var loc$1 = loc._0;
                        var key = GCL$Guacamole.Loc.toString(loc$1);
                        var range = GCL$Guacamole.Loc.toRange(loc$1);
                        return addBackground(state, key, range, "statusBar.debuggingBackground");
                    case /* MouseOut */1 :
                        return remove(GCL$Guacamole.Loc.toString(loc._0));
                    case /* MouseClick */2 :
                        console.log(response);
                        return ;
                    
                  }
                }))));
  return state;
}

function destroy(state) {
  Belt_Array.forEach(state.subscriptions, (function (prim) {
          return prim.dispose();
        }));
  state.subscriptions = [];
  
}

exports.subscribe = subscribe;
exports.display = display;
exports.handleStructError = handleStructError;
exports.handleTypeError = handleTypeError;
exports.handleError = handleError;
exports.handleResponseKind = handleResponseKind;
exports.Decoration = Decoration;
exports.make = make;
exports.destroy = destroy;
/* VSCode Not a pure module */
