// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Connection$Guacamole = require("./Connection.bs.js");
var VscodeImpl$Guacamole = require("./Editor/VscodeImpl.bs.js");

function Impl(Interface) {
  var Connection = Connection$Guacamole.Impl(Interface);
  var make = function (context, editor) {
    return {
            editor: editor,
            editor2: Curry._2(Interface.make, editor, context),
            connection: undefined,
            panel: undefined
          };
  };
  var destroy = function (state) {
    return Belt_Option.forEach(state.panel, (function (panel) {
                  panel.dispose();
                  return /* () */0;
                }));
  };
  var toString = function (param) {
    if (param.tag) {
      return /* tuple */[
              "JSON Decode Error",
              param[0] + ("\nJSON from GCL: \n" + JSON.stringify(param[1]))
            ];
    } else {
      return Curry._1(Connection.$$Error.toString, param[0]);
    }
  };
  var $$Error = {
    toString: toString
  };
  var establishConnection = function (state) {
    var match = state.connection;
    if (match !== undefined) {
      return $$Promise.resolved(/* Ok */Caml_chrome_debugger.variant("Ok", 0, [match]));
    } else {
      return $$Promise.tapOk($$Promise.mapError(Curry._1(Connection.make, /* () */0), (function (e) {
                        return /* Connection */Caml_chrome_debugger.variant("Connection", 0, [e]);
                      })), (function (conn) {
                    state.connection = conn;
                    return /* () */0;
                  }));
    }
  };
  return {
          Connection: Connection,
          make: make,
          destroy: destroy,
          $$Error: $$Error,
          establishConnection: establishConnection
        };
}

var Interface = {
  make: VscodeImpl$Guacamole.make,
  getExtensionPath: VscodeImpl$Guacamole.getExtensionPath,
  getFileName$prime: VscodeImpl$Guacamole.getFileName$prime,
  onDidChangeFileName: VscodeImpl$Guacamole.onDidChangeFileName,
  onDidCloseEditor: VscodeImpl$Guacamole.onDidCloseEditor,
  addToSubscriptions: VscodeImpl$Guacamole.addToSubscriptions,
  getGCLPath: VscodeImpl$Guacamole.getGCLPath,
  setGCLPath: VscodeImpl$Guacamole.setGCLPath
};

var Connection = Connection$Guacamole.Impl(Interface);

function make(context, editor) {
  return {
          editor: editor,
          editor2: VscodeImpl$Guacamole.make(editor, context),
          connection: undefined,
          panel: undefined
        };
}

function destroy(state) {
  return Belt_Option.forEach(state.panel, (function (panel) {
                panel.dispose();
                return /* () */0;
              }));
}

function toString(param) {
  if (param.tag) {
    return /* tuple */[
            "JSON Decode Error",
            param[0] + ("\nJSON from GCL: \n" + JSON.stringify(param[1]))
          ];
  } else {
    return Curry._1(Connection.$$Error.toString, param[0]);
  }
}

var $$Error = {
  toString: toString
};

function establishConnection(state) {
  var match = state.connection;
  if (match !== undefined) {
    return $$Promise.resolved(/* Ok */Caml_chrome_debugger.variant("Ok", 0, [match]));
  } else {
    return $$Promise.tapOk($$Promise.mapError(Curry._1(Connection.make, /* () */0), (function (e) {
                      return /* Connection */Caml_chrome_debugger.variant("Connection", 0, [e]);
                    })), (function (conn) {
                  state.connection = conn;
                  return /* () */0;
                }));
  }
}

exports.Impl = Impl;
exports.Connection = Connection;
exports.make = make;
exports.destroy = destroy;
exports.$$Error = $$Error;
exports.establishConnection = establishConnection;
/* Connection Not a pure module */
