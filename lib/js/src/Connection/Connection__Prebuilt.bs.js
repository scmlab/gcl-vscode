// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Url = require("url");
var Path = require("path");
var Curry = require("bs-platform/lib/js/curry.js");
var Https = require("https");
var Yauzl = require("yauzl");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Process = require("process");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Result = require("bs-platform/lib/js/belt_Result.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var Util$Guacamole = require("../Util/Util.bs.js");
var Config$Guacamole = require("../Config.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");

function unlink(path) {
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  Fs.unlink(path, (function (error) {
          if (error !== null) {
            return Curry._1(resolve, {
                        TAG: 1,
                        _0: error,
                        [Symbol.for("name")]: "Error"
                      });
          } else {
            return Curry._1(resolve, {
                        TAG: 0,
                        _0: undefined,
                        [Symbol.for("name")]: "Ok"
                      });
          }
        }));
  return match[0];
}

function rename(old, $$new) {
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  Fs.rename(old, $$new, (function (error) {
          if (error !== null) {
            return Curry._1(resolve, {
                        TAG: 1,
                        _0: error,
                        [Symbol.for("name")]: "Error"
                      });
          } else {
            return Curry._1(resolve, {
                        TAG: 0,
                        _0: undefined,
                        [Symbol.for("name")]: "Ok"
                      });
          }
        }));
  return match[0];
}

function readFile(path) {
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  Fs.readFile(path, (function (error, buffer) {
          if (error !== null) {
            return Curry._1(resolve, {
                        TAG: 1,
                        _0: error,
                        [Symbol.for("name")]: "Error"
                      });
          } else {
            return Curry._1(resolve, {
                        TAG: 0,
                        _0: buffer,
                        [Symbol.for("name")]: "Ok"
                      });
          }
        }));
  return match[0];
}

var Fs$1 = {
  unlink: unlink,
  rename: rename,
  readFile: readFile
};

var Https$1 = {};

var Url$1 = {};

var Nd = {
  Fs: Fs$1,
  Https: Https$1,
  Url: Url$1
};

function toString(x) {
  if (typeof x === "number") {
    if (x === /* NoRedirectLocation */0) {
      return "Got HTTP 301/302 from GitHub without location in headers";
    } else {
      return "Failed to unzip files";
    }
  }
  switch (x.TAG | 0) {
    case /* ResponseParseError */0 :
        return "Cannot parse release metadata from GitHub:\n" + x._0;
    case /* ResponseDecodeError */1 :
        return "Cannot decode release metadata JSON from GitHub:\n" + x._0;
    case /* ServerResponseError */2 :
        return "Server Response Error:\n" + Util$Guacamole.Exn.toString(x._0);
    case /* NoMatchingVersion */3 :
        return "Cannot find " + x._0 + " in releases from GitHub";
    case /* NotSupportedOS */4 :
        return "Cannot find prebuilt for " + x._0;
    case /* CannotDeleteFile */5 :
        return "Failed to delete files:\n" + Util$Guacamole.Exn.toString(x._0);
    case /* CannotRenameFile */6 :
        return "Failed to rename files:\n" + Util$Guacamole.Exn.toString(x._0);
    case /* CannotWriteFile */7 :
        return "Failed to  write files:\n" + Util$Guacamole.Exn.toString(x._0);
    case /* CannotUnzipFileWithExn */8 :
        return "Failed to unzip files:\n" + Util$Guacamole.Exn.toString(x._0);
    
  }
}

var $$Error = {
  toString: toString
};

function gatherDataFromResponse(res) {
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  var body = {
    contents: ""
  };
  res.on("data", (function (buf) {
          body.contents = body.contents + buf.toString();
          
        }));
  res.on("error", (function (error) {
          return Curry._1(resolve, {
                      TAG: 1,
                      _0: {
                        TAG: 2,
                        _0: error,
                        [Symbol.for("name")]: "ServerResponseError"
                      },
                      [Symbol.for("name")]: "Error"
                    });
        }));
  res.on("close", (function () {
          return Curry._1(resolve, {
                      TAG: 0,
                      _0: body.contents,
                      [Symbol.for("name")]: "Ok"
                    });
        }));
  return match[0];
}

function getWithRedirects(options) {
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  Https.get(options, (function (res) {
          var statusCode = res.statusCode;
          if (!(statusCode === 302 || statusCode === 301)) {
            return Curry._1(resolve, {
                        TAG: 0,
                        _0: res,
                        [Symbol.for("name")]: "Ok"
                      });
          }
          var headers = res.headers;
          var urlAfterRedirect = headers.location;
          if (urlAfterRedirect !== undefined) {
            Https.get(urlAfterRedirect, (function (resAfterRedirect) {
                    return Curry._1(resolve, {
                                TAG: 0,
                                _0: resAfterRedirect,
                                [Symbol.for("name")]: "Ok"
                              });
                  }));
            return ;
          } else {
            return Curry._1(resolve, {
                        TAG: 1,
                        _0: /* NoRedirectLocation */0,
                        [Symbol.for("name")]: "Error"
                      });
          }
        }));
  return match[0];
}

var HTTP = {
  gatherDataFromResponse: gatherDataFromResponse,
  getWithRedirects: getWithRedirects
};

var Entry = {};

var ZipFile = {};

var Yauzl$1 = {
  Entry: Entry,
  ZipFile: ZipFile
};

function run(src, dest) {
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  var fileStream = Fs.createWriteStream(dest, {
        mode: 484
      });
  fileStream.on("error", (function (exn) {
          return Curry._1(resolve, {
                      TAG: 1,
                      _0: {
                        TAG: 8,
                        _0: exn,
                        [Symbol.for("name")]: "CannotUnzipFileWithExn"
                      },
                      [Symbol.for("name")]: "Error"
                    });
        }));
  fileStream.on("close", (function () {
          return Curry._1(resolve, {
                      TAG: 0,
                      _0: undefined,
                      [Symbol.for("name")]: "Ok"
                    });
        }));
  Yauzl.open(src, (function (err, result) {
          if (err !== null) {
            return Curry._1(resolve, {
                        TAG: 1,
                        _0: {
                          TAG: 8,
                          _0: err,
                          [Symbol.for("name")]: "CannotUnzipFileWithExn"
                        },
                        [Symbol.for("name")]: "Error"
                      });
          }
          if (result === undefined) {
            return Curry._1(resolve, {
                        TAG: 1,
                        _0: /* CannotUnzipFile */1,
                        [Symbol.for("name")]: "Error"
                      });
          }
          var zipFile = Caml_option.valFromOption(result);
          zipFile.on("entry", (function (entry) {
                  zipFile.openReadStream(entry, (function (err2, result2) {
                          if (err2 !== null) {
                            return Curry._1(resolve, {
                                        TAG: 1,
                                        _0: {
                                          TAG: 8,
                                          _0: err2,
                                          [Symbol.for("name")]: "CannotUnzipFileWithExn"
                                        },
                                        [Symbol.for("name")]: "Error"
                                      });
                          } else if (result2 !== undefined) {
                            Caml_option.valFromOption(result2).pipe(fileStream);
                            return ;
                          } else {
                            return Curry._1(resolve, {
                                        TAG: 1,
                                        _0: /* CannotUnzipFile */1,
                                        [Symbol.for("name")]: "Error"
                                      });
                          }
                        }));
                  
                }));
          
        }));
  return match[0];
}

var Unzip = {
  Yauzl: Yauzl$1,
  run: run
};

function decode(json) {
  return {
          name: Json_decode.field("name", Json_decode.string, json),
          url: Json_decode.field("browser_download_url", Json_decode.string, json)
        };
}

var Asset = {
  decode: decode
};

function decode$1(json) {
  return {
          tagName: Json_decode.field("tag_name", Json_decode.string, json),
          assets: Json_decode.field("assets", (function (param) {
                  return Json_decode.array(decode, param);
                }), json)
        };
}

function parseMetadata(json) {
  try {
    return {
            TAG: 0,
            _0: Json_decode.array(decode$1, json),
            [Symbol.for("name")]: "Ok"
          };
  }
  catch (raw_e){
    var e = Caml_js_exceptions.internalToOCamlException(raw_e);
    if (e.RE_EXN_ID === Json_decode.DecodeError) {
      return {
              TAG: 1,
              _0: {
                TAG: 1,
                _0: e._1,
                _1: json,
                [Symbol.for("name")]: "ResponseDecodeError"
              },
              [Symbol.for("name")]: "Error"
            };
    }
    throw e;
  }
}

function getReleasesFromGitHub(param) {
  var httpOptions = {
    host: "api.github.com",
    path: "/repos/scmlab/gcl/releases",
    headers: {
      "User-Agent": "gcl-vscode"
    }
  };
  return $$Promise.flatMapOk($$Promise.flatMapOk(getWithRedirects(httpOptions), gatherDataFromResponse), (function (raw) {
                try {
                  return $$Promise.resolved(parseMetadata(JSON.parse(raw)));
                }
                catch (exn){
                  return $$Promise.resolved({
                              TAG: 1,
                              _0: {
                                TAG: 0,
                                _0: raw,
                                [Symbol.for("name")]: "ResponseParseError"
                              },
                              [Symbol.for("name")]: "Error"
                            });
                }
              }));
}

var Release = {
  decode: decode$1,
  parseMetadata: parseMetadata,
  getReleasesFromGitHub: getReleasesFromGitHub
};

function getCurrentVersion(globalStoragePath) {
  var getCurrentRelease = function (releases) {
    var matched = Belt_Array.keep(releases, (function (release) {
            return release.tagName === Config$Guacamole.version;
          }));
    var release = Belt_Array.get(matched, 0);
    if (release !== undefined) {
      return $$Promise.resolved({
                  TAG: 0,
                  _0: release,
                  [Symbol.for("name")]: "Ok"
                });
    } else {
      return $$Promise.resolved({
                  TAG: 1,
                  _0: {
                    TAG: 3,
                    _0: Config$Guacamole.version,
                    [Symbol.for("name")]: "NoMatchingVersion"
                  },
                  [Symbol.for("name")]: "Error"
                });
    }
  };
  var toDestPath = function (globalStoragePath, release, asset) {
    var osName = asset.name.slice(4, -4);
    return Path.join(globalStoragePath, "gcl-" + release.tagName + "-" + osName);
  };
  var getCurrentAsset = function (release) {
    var os = Process.platform;
    var expectedName;
    switch (os) {
      case "darwin" :
          expectedName = {
            TAG: 0,
            _0: "gcl-macos.zip",
            [Symbol.for("name")]: "Ok"
          };
          break;
      case "linux" :
          expectedName = {
            TAG: 0,
            _0: "gcl-ubuntu.zip",
            [Symbol.for("name")]: "Ok"
          };
          break;
      case "win32" :
          expectedName = {
            TAG: 0,
            _0: "gcl-windows.zip",
            [Symbol.for("name")]: "Ok"
          };
          break;
      default:
        expectedName = {
          TAG: 1,
          _0: {
            TAG: 4,
            _0: os,
            [Symbol.for("name")]: "NotSupportedOS"
          },
          [Symbol.for("name")]: "Error"
        };
    }
    return $$Promise.resolved(Belt_Result.flatMap(expectedName, (function (name) {
                      var matched = Belt_Array.keep(release.assets, (function (asset) {
                              return asset.name === name;
                            }));
                      var asset = Belt_Array.get(matched, 0);
                      if (asset !== undefined) {
                        return {
                                TAG: 0,
                                _0: {
                                  srcUrl: asset.url,
                                  destPath: toDestPath(globalStoragePath, release, asset),
                                  version: release.tagName
                                },
                                [Symbol.for("name")]: "Ok"
                              };
                      } else {
                        return {
                                TAG: 1,
                                _0: {
                                  TAG: 4,
                                  _0: os,
                                  [Symbol.for("name")]: "NotSupportedOS"
                                },
                                [Symbol.for("name")]: "Error"
                              };
                      }
                    })));
  };
  return $$Promise.flatMapOk($$Promise.flatMapOk(getReleasesFromGitHub(undefined), getCurrentRelease), getCurrentAsset);
}

var Metadata = {
  Asset: Asset,
  Release: Release,
  getCurrentVersion: getCurrentVersion
};

function download(srcUrl, destPath) {
  var url = Url.parse(srcUrl);
  var httpOptions = {
    host: url.host,
    path: url.path,
    headers: {
      "User-Agent": "gcl-vscode"
    }
  };
  return $$Promise.flatMapOk(getWithRedirects(httpOptions), (function (res) {
                var match = $$Promise.pending(undefined);
                var resolve = match[1];
                var fileStream = Fs.createWriteStream(destPath);
                fileStream.on("error", (function (exn) {
                        return Curry._1(resolve, {
                                    TAG: 1,
                                    _0: {
                                      TAG: 7,
                                      _0: exn,
                                      [Symbol.for("name")]: "CannotWriteFile"
                                    },
                                    [Symbol.for("name")]: "Error"
                                  });
                      }));
                fileStream.on("close", (function () {
                        return Curry._1(resolve, {
                                    TAG: 0,
                                    _0: undefined,
                                    [Symbol.for("name")]: "Ok"
                                  });
                      }));
                res.pipe(fileStream);
                return match[0];
              }));
}

function downloadLanguageServer(metadata) {
  return $$Promise.flatMap($$Promise.flatMapOk($$Promise.flatMapOk($$Promise.flatMapOk(download(metadata.srcUrl, metadata.destPath + ".zip.download"), (function (param) {
                            return $$Promise.mapError(rename(metadata.destPath + ".zip.download", metadata.destPath + ".zip"), (function (e) {
                                          return {
                                                  TAG: 6,
                                                  _0: e,
                                                  [Symbol.for("name")]: "CannotRenameFile"
                                                };
                                        }));
                          })), (function (param) {
                        return run(metadata.destPath + ".zip", metadata.destPath);
                      })), (function (param) {
                    return $$Promise.mapError(unlink(metadata.destPath + ".zip"), (function (e) {
                                  return {
                                          TAG: 5,
                                          _0: e,
                                          [Symbol.for("name")]: "CannotDeleteFile"
                                        };
                                }));
                  })), (function (result) {
                if (result.TAG === /* Ok */0) {
                  return $$Promise.resolved({
                              TAG: 0,
                              _0: metadata.destPath,
                              [Symbol.for("name")]: "Ok"
                            });
                }
                var error = result._0;
                var remove = function (path) {
                  if (Fs.existsSync(path)) {
                    return $$Promise.map(unlink(path), (function (param) {
                                  
                                }));
                  } else {
                    return $$Promise.resolved(undefined);
                  }
                };
                return $$Promise.map($$Promise.allArray([
                                remove(metadata.destPath + ".zip.download"),
                                remove(metadata.destPath + ".zip")
                              ]), (function (param) {
                              return {
                                      TAG: 1,
                                      _0: error,
                                      [Symbol.for("name")]: "Error"
                                    };
                            }));
              }));
}

function checkExistingDownload(globalStoragePath) {
  if (!Fs.existsSync(globalStoragePath)) {
    Fs.mkdirSync(globalStoragePath);
  }
  var others = Process.platform;
  var getExpectedFileName;
  switch (others) {
    case "darwin" :
        getExpectedFileName = {
          TAG: 0,
          _0: "gcl-" + Config$Guacamole.version + "-macos",
          [Symbol.for("name")]: "Ok"
        };
        break;
    case "linux" :
        getExpectedFileName = {
          TAG: 0,
          _0: "gcl-" + Config$Guacamole.version + "-ubuntu",
          [Symbol.for("name")]: "Ok"
        };
        break;
    case "win32" :
        getExpectedFileName = {
          TAG: 0,
          _0: "gcl-" + Config$Guacamole.version + "-windows",
          [Symbol.for("name")]: "Ok"
        };
        break;
    default:
      getExpectedFileName = {
        TAG: 1,
        _0: {
          TAG: 4,
          _0: others,
          [Symbol.for("name")]: "NotSupportedOS"
        },
        [Symbol.for("name")]: "Error"
      };
  }
  return Belt_Result.map(getExpectedFileName, (function (expected) {
                var fileNames = Fs.readdirSync(globalStoragePath);
                var downloaded = fileNames.some(function (actual) {
                      return expected === actual;
                    });
                if (downloaded) {
                  return Path.join(globalStoragePath, expected);
                }
                
              }));
}

var state = {
  contents: undefined
};

function get(globalStoragePath) {
  var match = state.contents;
  if (match !== undefined) {
    if (match.TAG === /* Downloaded */0) {
      return $$Promise.resolved({
                  TAG: 0,
                  _0: match._0,
                  [Symbol.for("name")]: "Ok"
                });
    } else {
      return match._0;
    }
  }
  var error = checkExistingDownload(globalStoragePath);
  if (error.TAG !== /* Ok */0) {
    return $$Promise.resolved({
                TAG: 1,
                _0: error._0,
                [Symbol.for("name")]: "Error"
              });
  }
  var path = error._0;
  if (path !== undefined) {
    state.contents = {
      TAG: 0,
      _0: path,
      [Symbol.for("name")]: "Downloaded"
    };
    return $$Promise.resolved({
                TAG: 0,
                _0: path,
                [Symbol.for("name")]: "Ok"
              });
  }
  var match$1 = $$Promise.pending(undefined);
  state.contents = {
    TAG: 1,
    _0: match$1[0],
    [Symbol.for("name")]: "InFlight"
  };
  return $$Promise.tap($$Promise.flatMapOk(getCurrentVersion(globalStoragePath), downloadLanguageServer), match$1[1]);
}

var Module = {
  get: get
};

exports.Nd = Nd;
exports.$$Error = $$Error;
exports.HTTP = HTTP;
exports.Unzip = Unzip;
exports.Metadata = Metadata;
exports.Module = Module;
exports.get = get;
/* fs Not a pure module */
