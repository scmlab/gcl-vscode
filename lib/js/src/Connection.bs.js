// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Net = require("net");
var Curry = require("bs-platform/lib/js/curry.js");
var VSCode = require("bs-vscode/lib/js/src/VSCode.bs.js");
var Vscode = require("vscode");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var LSP$Guacamole = require("./LSP.bs.js");
var Chan$Guacamole = require("./Util/Chan.bs.js");
var Request$Guacamole = require("./Request.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var Response$Guacamole = require("./Response.bs.js");
var VscodeLanguageclient = require("vscode-languageclient");
var Process$AgdaModeVscode = require("agda-mode-vscode/lib/js/src/Process.bs.js");

var $$Error = {};

function probe(name) {
  return $$Promise.mapError($$Promise.mapOk(Process$AgdaModeVscode.PathSearch.run(name), (function (path) {
                    return {
                            TAG: 0,
                            _0: name,
                            _1: path.trim(),
                            [Symbol.for("name")]: "ViaStdIO"
                          };
                  })), (function (e) {
                return {
                        TAG: 0,
                        _0: e,
                        [Symbol.for("name")]: "CannotConnectViaStdIO"
                      };
              }));
}

function probe$1(port) {
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  var socket = Net.connect(port, (function (param) {
          return Curry._1(resolve, {
                      TAG: 0,
                      _0: undefined,
                      [Symbol.for("name")]: "Ok"
                    });
        }));
  socket.on("error", (function (exn) {
          return Curry._1(resolve, {
                      TAG: 1,
                      _0: {
                        TAG: 1,
                        _0: exn,
                        [Symbol.for("name")]: "CannotConnectViaTCP"
                      },
                      [Symbol.for("name")]: "Error"
                    });
        }));
  return $$Promise.mapOk(match[0], (function (param) {
                socket.destroy();
                return {
                        TAG: 1,
                        _0: port,
                        [Symbol.for("name")]: "ViaTCP"
                      };
              }));
}

var errorChan = Chan$Guacamole.make(undefined);

var dataChan = Chan$Guacamole.make(undefined);

function onError(callback) {
  return new Vscode.Disposable(Chan$Guacamole.on(errorChan, (function (e) {
                    return Curry._1(callback, {
                                TAG: 2,
                                _0: e,
                                [Symbol.for("name")]: "ConnectionError"
                              });
                  })));
}

function sendRequest(self, data) {
  return $$Promise.mapError($$Promise.flatMapOk($$Promise.Js.toResult(self.client.onReady()), (function (param) {
                    return $$Promise.Js.toResult(self.client.sendRequest("guacamole", data));
                  })), (function (exn) {
                return {
                        TAG: 3,
                        _0: exn,
                        [Symbol.for("name")]: "CannotSendRequest"
                      };
              }));
}

function make(method) {
  var serverOptions;
  serverOptions = method.TAG === /* ViaStdIO */0 ? LSP$Guacamole.ServerOptions.makeWithCommand(method._0) : LSP$Guacamole.ServerOptions.makeWithStreamInfo(method._0);
  var documentSelector = [VSCode.StringOr.others({
          language: "guacamole",
          pattern: undefined,
          scheme: "file"
        })];
  var synchronize = Vscode.workspace.createFileSystemWatcher('**/.clientrc', false, false, false);
  var errorHandler = LSP$Guacamole.ErrorHandler.make((function (exn, _msg, _count) {
          Chan$Guacamole.emit(errorChan, exn);
          return /* Shutdown */1;
        }), (function (param) {
          return /* DoNotRestart */0;
        }));
  var clientOptions = LSP$Guacamole.LanguageClientOptions.make(documentSelector, synchronize, errorHandler);
  var languageClient = new VscodeLanguageclient.LanguageClient("guacamoleLanguageServer", "Guacamole Language Server", serverOptions, clientOptions);
  var self_queue = [];
  var self_subscription = languageClient.start();
  var self = {
    client: languageClient,
    queue: self_queue,
    subscription: self_subscription,
    method: method
  };
  return $$Promise.mapError($$Promise.map($$Promise.race({
                      hd: $$Promise.Js.toResult(languageClient.onReady()),
                      tl: {
                        hd: $$Promise.map(Chan$Guacamole.once(errorChan), (function (err) {
                                return {
                                        TAG: 1,
                                        _0: err,
                                        [Symbol.for("name")]: "Error"
                                      };
                              })),
                        tl: /* [] */0
                      }
                    }), (function (result) {
                    if (result.TAG !== /* Ok */0) {
                      return {
                              TAG: 1,
                              _0: result._0,
                              [Symbol.for("name")]: "Error"
                            };
                    }
                    languageClient.onNotification("guacamole", (function (json) {
                            return Chan$Guacamole.emit(dataChan, json);
                          }));
                    return {
                            TAG: 0,
                            _0: self,
                            [Symbol.for("name")]: "Ok"
                          };
                  })), (function (e) {
                return {
                        TAG: 2,
                        _0: e,
                        [Symbol.for("name")]: "ConnectionError"
                      };
              }));
}

function probe$2(tryTCP) {
  var name = "gcl";
  if (tryTCP) {
    return $$Promise.flatMapError(probe$1(3000), (function (param) {
                  return probe(name);
                }));
  } else {
    return probe(name);
  }
}

var singleton = {
  contents: undefined
};

function make$1(tryTCP) {
  var _client = singleton.contents;
  if (_client !== undefined) {
    return $$Promise.resolved({
                TAG: 0,
                _0: undefined,
                [Symbol.for("name")]: "Ok"
              });
  } else {
    return $$Promise.mapOk($$Promise.flatMapOk(probe$2(tryTCP), make), (function (client) {
                  singleton.contents = client;
                  
                }));
  }
}

function destroy(param) {
  var client = singleton.contents;
  if (client !== undefined) {
    client.subscription.dispose();
    return $$Promise.map($$Promise.Js.toResult(client.client.stop()), (function (param) {
                  
                }));
  } else {
    return $$Promise.resolved(undefined);
  }
}

function decodeResponse(json) {
  var response;
  try {
    response = Response$Guacamole.decode(json);
  }
  catch (raw_msg){
    var msg = Caml_js_exceptions.internalToOCamlException(raw_msg);
    if (msg.RE_EXN_ID === Json_decode.DecodeError) {
      return {
              TAG: 1,
              _0: {
                TAG: 4,
                _0: msg._1,
                _1: json,
                [Symbol.for("name")]: "CannotDecodeResponse"
              },
              [Symbol.for("name")]: "Error"
            };
    }
    throw msg;
  }
  return {
          TAG: 0,
          _0: response,
          [Symbol.for("name")]: "Ok"
        };
}

function sendRequest$1(request) {
  var client = singleton.contents;
  if (client !== undefined) {
    return $$Promise.flatMapOk(sendRequest(client, Request$Guacamole.encode(request)), (function (json) {
                  return $$Promise.resolved(decodeResponse(json));
                }));
  } else {
    return $$Promise.resolved({
                TAG: 1,
                _0: /* NotConnectedYet */0,
                [Symbol.for("name")]: "Error"
              });
  }
}

function onResponse(handler) {
  return new Vscode.Disposable(Chan$Guacamole.on(dataChan, (function (json) {
                    return Curry._1(handler, decodeResponse(json));
                  })));
}

function getMethod(param) {
  var client = singleton.contents;
  if (client !== undefined) {
    return client.method;
  }
  
}

var Module = {
  make: make$1,
  destroy: destroy,
  sendRequest: sendRequest$1,
  onResponse: onResponse,
  onError: onError,
  getMethod: getMethod
};

exports.$$Error = $$Error;
exports.Module = Module;
exports.make = make$1;
exports.destroy = destroy;
exports.sendRequest = sendRequest$1;
exports.onResponse = onResponse;
exports.onError = onError;
exports.getMethod = getMethod;
/* errorChan Not a pure module */
