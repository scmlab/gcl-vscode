// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Net = require("net");
var Curry = require("rescript/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var Config$Guabao = require("./Config.bs.js");
var Request$Guabao = require("./Request.bs.js");
var Response$Guabao = require("./Response.bs.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");
var Connection__Client$Guabao = require("./Connection/Connection__Client.bs.js");
var Search$LanguageServerMule = require("language-server-mule/lib/js/src/Search.bs.js");
var Connection__Prebuilt$Guabao = require("./Connection/Connection__Prebuilt.bs.js");

function probe(port) {
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  var socket = Net.connect(port, (function (param) {
          return Curry._1(resolve, {
                      TAG: 0,
                      _0: undefined,
                      [Symbol.for("name")]: "Ok"
                    });
        }));
  socket.on("error", (function (exn) {
          return Curry._1(resolve, {
                      TAG: 1,
                      _0: {
                        TAG: 1,
                        _0: exn,
                        [Symbol.for("name")]: "CannotConnectViaTCP"
                      },
                      [Symbol.for("name")]: "Error"
                    });
        }));
  return $$Promise.mapOk(match[0], (function (param) {
                socket.destroy();
                return {
                        TAG: 1,
                        _0: port,
                        [Symbol.for("name")]: "ViaTCP"
                      };
              }));
}

function probe$1(globalStoragePath) {
  return $$Promise.flatMapError($$Promise.flatMapError(probe(3000), (function (param) {
                    return $$Promise.mapError($$Promise.mapOk(Connection__Prebuilt$Guabao.get(globalStoragePath), (function (path) {
                                      return {
                                              TAG: 2,
                                              _0: Config$Guabao.version,
                                              _1: path.trim(),
                                              [Symbol.for("name")]: "ViaPrebuilt"
                                            };
                                    })), (function (e) {
                                  return {
                                          TAG: 2,
                                          _0: e,
                                          [Symbol.for("name")]: "CannotConnectViaPrebuilt"
                                        };
                                }));
                  })), (function (param) {
                var name = "gcl";
                return $$Promise.mapError($$Promise.mapOk(Search$LanguageServerMule.Path.run(name), (function (path) {
                                  return {
                                          TAG: 0,
                                          _0: name,
                                          _1: path.trim(),
                                          [Symbol.for("name")]: "ViaStdIO"
                                        };
                                })), (function (e) {
                              return {
                                      TAG: 0,
                                      _0: e,
                                      [Symbol.for("name")]: "CannotConnectViaStdIO"
                                    };
                            }));
              }));
}

var singleton = {
  contents: /* Disconnected */0
};

function getPendingRequests(param) {
  var match = singleton.contents;
  if (typeof match === "number") {
    return [];
  } else if (match.TAG === /* Connecting */0) {
    return match._0;
  } else {
    return [];
  }
}

function decodeResponse(json) {
  var response;
  try {
    response = Response$Guabao.decode(json);
  }
  catch (raw_msg){
    var msg = Caml_js_exceptions.internalToOCamlException(raw_msg);
    if (msg.RE_EXN_ID === Json_decode.DecodeError) {
      return {
              TAG: 1,
              _0: {
                TAG: 5,
                _0: msg._1,
                _1: json,
                [Symbol.for("name")]: "CannotDecodeResponse"
              },
              [Symbol.for("name")]: "Error"
            };
    }
    throw msg;
  }
  return {
          TAG: 0,
          _0: response,
          [Symbol.for("name")]: "Ok"
        };
}

function start(globalStoragePath) {
  var client = singleton.contents;
  if (typeof client !== "number") {
    if (client.TAG === /* Connecting */0) {
      return client._1;
    } else {
      return $$Promise.resolved({
                  TAG: 0,
                  _0: Connection__Client$Guabao.getMethod(client._0),
                  [Symbol.for("name")]: "Ok"
                });
    }
  }
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  singleton.contents = {
    TAG: 0,
    _0: [],
    _1: match[0],
    [Symbol.for("name")]: "Connecting"
  };
  return $$Promise.map($$Promise.flatMapOk(probe$1(globalStoragePath), Connection__Client$Guabao.make), (function (result) {
                if (result.TAG === /* Ok */0) {
                  var client = result._0;
                  singleton.contents = {
                    TAG: 1,
                    _0: client,
                    [Symbol.for("name")]: "Connected"
                  };
                  Belt_Array.forEach(getPendingRequests(undefined), (function (param) {
                          return $$Promise.get($$Promise.flatMapOk(Connection__Client$Guabao.sendRequest(client, Request$Guabao.encode(param[0])), (function (json) {
                                            return $$Promise.resolved(decodeResponse(json));
                                          })), param[1]);
                        }));
                  Curry._1(resolve, {
                        TAG: 0,
                        _0: Connection__Client$Guabao.getMethod(client),
                        [Symbol.for("name")]: "Ok"
                      });
                  console.log("[ connection ] established");
                  return {
                          TAG: 0,
                          _0: Connection__Client$Guabao.getMethod(client),
                          [Symbol.for("name")]: "Ok"
                        };
                }
                var error = result._0;
                singleton.contents = /* Disconnected */0;
                Belt_Array.forEach(getPendingRequests(undefined), (function (param) {
                        return Curry._1(param[1], {
                                    TAG: 1,
                                    _0: error,
                                    [Symbol.for("name")]: "Error"
                                  });
                      }));
                Curry._1(resolve, {
                      TAG: 1,
                      _0: error,
                      [Symbol.for("name")]: "Error"
                    });
                return {
                        TAG: 1,
                        _0: error,
                        [Symbol.for("name")]: "Error"
                      };
              }));
}

function stop(param) {
  var client = singleton.contents;
  if (typeof client === "number") {
    return $$Promise.resolved(undefined);
  }
  if (client.TAG === /* Connecting */0) {
    return $$Promise.flatMap(client._1, (function (param) {
                  return stop(undefined);
                }));
  }
  singleton.contents = /* Disconnected */0;
  console.log("[ connection ] severed");
  return Connection__Client$Guabao.destroy(client._0);
}

function sendRequest(globalStoragePath, request) {
  var client = singleton.contents;
  if (typeof client === "number") {
    return $$Promise.flatMapOk(start(globalStoragePath), (function (param) {
                  return sendRequest(globalStoragePath, request);
                }));
  }
  if (client.TAG !== /* Connecting */0) {
    return $$Promise.flatMapOk(Connection__Client$Guabao.sendRequest(client._0, Request$Guabao.encode(request)), (function (json) {
                  return $$Promise.resolved(decodeResponse(json));
                }));
  }
  var match = $$Promise.pending(undefined);
  client._0.push([
        request,
        match[1]
      ]);
  return match[0];
}

function onResponse(handler) {
  return Connection__Client$Guabao.onResponse(function (json) {
              return Curry._1(handler, decodeResponse(json));
            });
}

var Module = {
  start: start,
  stop: stop,
  sendRequest: sendRequest,
  onResponse: onResponse,
  onError: Connection__Client$Guabao.onError
};

var Client;

var $$Error;

var onError = Connection__Client$Guabao.onError;

exports.Client = Client;
exports.$$Error = $$Error;
exports.Module = Module;
exports.start = start;
exports.stop = stop;
exports.sendRequest = sendRequest;
exports.onResponse = onResponse;
exports.onError = onError;
/* net Not a pure module */
