// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Vscode = require("vscode");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Chan$Guabao = require("./Util/Chan.bs.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var Child_process = require("child_process");
var Request$Guabao = require("./Request.bs.js");
var Response$Guabao = require("./Response.bs.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");
var Connection__Probe$Guabao = require("./Connection/Connection__Probe.bs.js");
var Client__LSP$LanguageServerMule = require("language-server-mule/lib/js/src/Client/Client__LSP.bs.js");

var Method = {};

var singleton = {
  contents: /* Disconnected */0
};

var errorChan = Chan$Guabao.make(undefined);

var notificationChan = Chan$Guabao.make(undefined);

function getPendingRequests(param) {
  var match = singleton.contents;
  if (typeof match === "number") {
    return [];
  } else if (match.TAG === /* Connecting */0) {
    return match._0;
  } else {
    return [];
  }
}

function decodeResponse(json) {
  var response;
  try {
    response = Response$Guabao.decode(json);
  }
  catch (raw_msg){
    var msg = Caml_js_exceptions.internalToOCamlException(raw_msg);
    if (msg.RE_EXN_ID === Json_decode.DecodeError) {
      return {
              TAG: /* Error */1,
              _0: {
                TAG: /* CannotDecodeResponse */2,
                _0: msg._1,
                _1: json
              }
            };
    }
    throw msg;
  }
  return {
          TAG: /* Ok */0,
          _0: response
        };
}

function start(globalStoragePath, onDownload) {
  var match = singleton.contents;
  if (typeof match !== "number") {
    if (match.TAG === /* Connecting */0) {
      return match._1;
    } else {
      return $$Promise.resolved({
                  TAG: /* Ok */0,
                  _0: match._1
                });
    }
  }
  var match$1 = $$Promise.pending(undefined);
  var resolve = match$1[1];
  singleton.contents = {
    TAG: /* Connecting */0,
    _0: [],
    _1: match$1[0]
  };
  return $$Promise.map($$Promise.flatMapOk($$Promise.mapError(Connection__Probe$Guabao.probe(globalStoragePath, onDownload), (function (error) {
                        return {
                                TAG: /* CannotAcquireHandle */0,
                                _0: error
                              };
                      })), (function (probedMethod) {
                    var match;
                    if (probedMethod.TAG === /* ViaCommand */0) {
                      var source = probedMethod._3;
                      var commandPath = probedMethod._0;
                      var host = "localhost";
                      var backendChildProcess = Child_process.spawn(commandPath, ["-d"]);
                      console.log("[ connection ] spawned the backend server");
                      Child_process.spawnSync("sleep", ["0.5"], {});
                      var shownMethod;
                      if (source.TAG === /* FromGitHub */3) {
                        Vscode.workspace.getConfiguration(undefined, undefined).update("guabao.gclPath", commandPath, 1, undefined);
                        shownMethod = {
                          TAG: /* GithubPrebuilt */0,
                          _0: commandPath,
                          _1: source._1,
                          _2: backendChildProcess
                        };
                      } else {
                        shownMethod = {
                          TAG: /* Command */1,
                          _0: commandPath,
                          _1: backendChildProcess
                        };
                      }
                      match = [
                        {
                          TAG: /* ViaTCP */1,
                          _0: 3000,
                          _1: host,
                          _2: {
                            TAG: /* FromTCP */2,
                            _0: 3000,
                            _1: host
                          }
                        },
                        shownMethod
                      ];
                    } else {
                      match = [
                        probedMethod,
                        {
                          TAG: /* TCP */2,
                          _0: probedMethod._0,
                          _1: probedMethod._1
                        }
                      ];
                    }
                    var shownMethod$1 = match[1];
                    return $$Promise.mapOk($$Promise.mapError(Client__LSP$LanguageServerMule.make("guabao", "Guabao Language Server", match[0], null), (function (e) {
                                      return {
                                              TAG: /* ConnectionError */1,
                                              _0: e
                                            };
                                    })), (function (client) {
                                  return [
                                          client,
                                          shownMethod$1
                                        ];
                                }));
                  })), (function (result) {
                if (result.TAG === /* Ok */0) {
                  var match = result._0;
                  var shownMethod = match[1];
                  var client = match[0];
                  var subsriptions = [];
                  singleton.contents = {
                    TAG: /* Connected */1,
                    _0: client,
                    _1: shownMethod,
                    _2: subsriptions
                  };
                  Belt_Array.forEach(getPendingRequests(undefined), (function (param) {
                          return $$Promise.get($$Promise.flatMapOk($$Promise.mapError(Client__LSP$LanguageServerMule.sendRequest(client, Request$Guabao.encode(param[0])), (function (e) {
                                                return {
                                                        TAG: /* ConnectionError */1,
                                                        _0: e
                                                      };
                                              })), (function (json) {
                                            return $$Promise.resolved(decodeResponse(json));
                                          })), param[1]);
                        }));
                  Curry._1(resolve, {
                        TAG: /* Ok */0,
                        _0: shownMethod
                      });
                  subsriptions.push(Client__LSP$LanguageServerMule.onNotification(client, (function (json) {
                              return Chan$Guabao.emit(notificationChan, decodeResponse(json));
                            })));
                  subsriptions.push(Client__LSP$LanguageServerMule.onError(client, (function (error) {
                              return Chan$Guabao.emit(errorChan, {
                                          TAG: /* ConnectionError */1,
                                          _0: error
                                        });
                            })));
                  return {
                          TAG: /* Ok */0,
                          _0: shownMethod
                        };
                }
                var error = result._0;
                singleton.contents = /* Disconnected */0;
                Belt_Array.forEach(getPendingRequests(undefined), (function (param) {
                        return Curry._1(param[1], {
                                    TAG: /* Error */1,
                                    _0: error
                                  });
                      }));
                Curry._1(resolve, {
                      TAG: /* Error */1,
                      _0: error
                    });
                return {
                        TAG: /* Error */1,
                        _0: error
                      };
              }));
}

function stop(param) {
  var match = singleton.contents;
  if (typeof match === "number") {
    return $$Promise.resolved(undefined);
  }
  if (match.TAG === /* Connecting */0) {
    return $$Promise.flatMap(match._1, (function (param) {
                  return stop(undefined);
                }));
  }
  var method = match._1;
  singleton.contents = /* Disconnected */0;
  console.log("[ connection ] stop");
  Belt_Array.forEach(match._2, (function (prim) {
          return prim.dispose();
        }));
  return $$Promise.map(Client__LSP$LanguageServerMule.destroy(match._0), (function (param) {
                switch (method.TAG | 0) {
                  case /* GithubPrebuilt */0 :
                      method._2.kill("SIGTERM");
                      break;
                  case /* Command */1 :
                      method._1.kill("SIGTERM");
                      break;
                  case /* TCP */2 :
                      break;
                  
                }
                Child_process.spawnSync("sleep", ["0.5"], {});
                
              }));
}

function sendRequest(globalStoragePath, onDownload, request) {
  var match = singleton.contents;
  if (typeof match === "number") {
    return $$Promise.flatMapOk(start(globalStoragePath, onDownload), (function (param) {
                  return sendRequest(globalStoragePath, onDownload, request);
                }));
  }
  if (match.TAG !== /* Connecting */0) {
    return $$Promise.flatMapOk($$Promise.mapError(Client__LSP$LanguageServerMule.sendRequest(match._0, Request$Guabao.encode(request)), (function (e) {
                      return {
                              TAG: /* ConnectionError */1,
                              _0: e
                            };
                    })), (function (json) {
                  return $$Promise.resolved(decodeResponse(json));
                }));
  }
  var match$1 = $$Promise.pending(undefined);
  match._0.push([
        request,
        match$1[1]
      ]);
  return match$1[0];
}

function onNotification(handler) {
  return new Vscode.Disposable(Chan$Guabao.on(notificationChan, handler));
}

function onError(handler) {
  return new Vscode.Disposable(Chan$Guabao.on(errorChan, handler));
}

function methodToString(method) {
  switch (method.TAG | 0) {
    case /* GithubPrebuilt */0 :
        return "Prebuilt " + method._1.tagName;
    case /* Command */1 :
        return "ViaStdIO";
    case /* TCP */2 :
        return "TCP";
    
  }
}

var Module = {
  start: start,
  stop: stop,
  sendRequest: sendRequest,
  onNotification: onNotification,
  onError: onError,
  methodToString: methodToString
};

var Client;

var $$Error;

var Probe;

exports.Client = Client;
exports.$$Error = $$Error;
exports.Probe = Probe;
exports.Method = Method;
exports.Module = Module;
exports.start = start;
exports.stop = stop;
exports.sendRequest = sendRequest;
exports.onNotification = onNotification;
exports.onError = onError;
exports.methodToString = methodToString;
/* errorChan Not a pure module */
