// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Vscode = require("vscode");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Process = require("process");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Chan$Guabao = require("./Util/Chan.bs.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var Config$Guabao = require("./Config.bs.js");
var Request$Guabao = require("./Request.bs.js");
var Response$Guabao = require("./Response.bs.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");
var Connection__Error$Guabao = require("./Connection/Connection__Error.bs.js");
var Source$LanguageServerMule = require("language-server-mule/lib/js/src/Source.bs.js");
var Client__LSP$LanguageServerMule = require("language-server-mule/lib/js/src/Client/Client__LSP.bs.js");

function chooseFromReleases(releases) {
  var getRelease = function (releases) {
    var matched = Belt_Array.keep(releases, (function (release) {
            return release.tagName === Config$Guabao.version;
          }));
    return Belt_Array.get(matched, 0);
  };
  var toFileName = function (release, asset) {
    var osName = asset.name.slice(4, -4);
    return release.tagName + "-" + osName;
  };
  var getAsset = function (release) {
    var os = Process.platform;
    var expectedName;
    switch (os) {
      case "darwin" :
          expectedName = "gcl-macos.zip";
          break;
      case "linux" :
          expectedName = "gcl-ubuntu.zip";
          break;
      case "win32" :
          expectedName = "gcl-windows.zip";
          break;
      default:
        expectedName = undefined;
    }
    return Belt_Option.map(Belt_Option.flatMap(expectedName, (function (name) {
                      var matched = Belt_Array.keep(release.assets, (function (asset) {
                              return asset.name === name;
                            }));
                      return Belt_Array.get(matched, 0);
                    })), (function (asset) {
                  return {
                          srcUrl: asset.url,
                          fileName: toFileName(release, asset)
                        };
                }));
  };
  return Belt_Option.flatMap(getRelease(releases), getAsset);
}

function probe(globalStoragePath) {
  return $$Promise.mapError(Source$LanguageServerMule.searchUntilSuccess([
                  {
                    TAG: /* FromTCP */1,
                    _0: 3000,
                    _1: "localhost"
                  },
                  {
                    TAG: /* FromPath */0,
                    _0: "gcl"
                  },
                  {
                    TAG: /* FromGitHub */2,
                    _0: {
                      username: "scmlab",
                      repository: "gcl",
                      userAgent: "gcl-vscode",
                      globalStoragePath: globalStoragePath,
                      chooseFromReleases: chooseFromReleases
                    }
                  }
                ]), (function (e) {
                console.log("LanguageServerMule.Source.searchUntilSuccess " + Source$LanguageServerMule.$$Error.toString(e));
                return {
                        TAG: /* CannotAcquireHandle */0,
                        _0: e
                      };
              }));
}

var singleton = {
  contents: /* Disconnected */0
};

var errorChan = Chan$Guabao.make(undefined);

var notificationChan = Chan$Guabao.make(undefined);

function getPendingRequests(param) {
  var match = singleton.contents;
  if (typeof match === "number") {
    return [];
  } else if (match.TAG === /* Connecting */0) {
    return match._0;
  } else {
    return [];
  }
}

function decodeResponse(json) {
  var response;
  try {
    response = Response$Guabao.decode(json);
  }
  catch (raw_msg){
    var msg = Caml_js_exceptions.internalToOCamlException(raw_msg);
    if (msg.RE_EXN_ID === Json_decode.DecodeError) {
      return {
              TAG: /* Error */1,
              _0: {
                TAG: /* CannotDecodeResponse */4,
                _0: msg._1,
                _1: json
              }
            };
    }
    throw msg;
  }
  return {
          TAG: /* Ok */0,
          _0: response
        };
}

function start(globalStoragePath) {
  var client = singleton.contents;
  if (typeof client === "number") {
    console.log("[ connection ] not established");
    var match = $$Promise.pending(undefined);
    var resolve = match[1];
    singleton.contents = {
      TAG: /* Connecting */0,
      _0: [],
      _1: match[0]
    };
    return $$Promise.map($$Promise.flatMapOk(probe(globalStoragePath), (function (handle) {
                      console.log("[ connection ] got handle", handle);
                      return $$Promise.mapError($$Promise.tap(Client__LSP$LanguageServerMule.make("guabao", "Guabao Language Server", handle), (function (param) {
                                        console.log("WTF", param);
                                        
                                      })), (function (e) {
                                    return {
                                            TAG: /* LSPClientError */1,
                                            _0: e
                                          };
                                  }));
                    })), (function (result) {
                  if (result.TAG === /* Ok */0) {
                    var client = result._0;
                    console.log("[ connection ] established");
                    singleton.contents = {
                      TAG: /* Connected */1,
                      _0: client
                    };
                    Belt_Array.forEach(getPendingRequests(undefined), (function (param) {
                            return $$Promise.get($$Promise.flatMapOk($$Promise.mapError(Client__LSP$LanguageServerMule.sendRequest(client, Request$Guabao.encode(param[0])), (function (e) {
                                                  return {
                                                          TAG: /* LSPClientError */1,
                                                          _0: e
                                                        };
                                                })), (function (json) {
                                              return $$Promise.resolved(decodeResponse(json));
                                            })), param[1]);
                          }));
                    Curry._1(resolve, {
                          TAG: /* Ok */0,
                          _0: Client__LSP$LanguageServerMule.getHandle(client)
                        });
                    return {
                            TAG: /* Ok */0,
                            _0: Client__LSP$LanguageServerMule.getHandle(client)
                          };
                  }
                  var error = result._0;
                  console.log("[ connection ] error when connecting", Connection__Error$Guabao.toString(error));
                  singleton.contents = /* Disconnected */0;
                  Belt_Array.forEach(getPendingRequests(undefined), (function (param) {
                          return Curry._1(param[1], {
                                      TAG: /* Error */1,
                                      _0: error
                                    });
                        }));
                  Curry._1(resolve, {
                        TAG: /* Error */1,
                        _0: error
                      });
                  return {
                          TAG: /* Error */1,
                          _0: error
                        };
                }));
  }
  if (client.TAG === /* Connecting */0) {
    console.log("[ connection ] still connecting ...");
    return client._1;
  }
  var client$1 = client._0;
  console.log("[ connection ] already established", client$1);
  return $$Promise.resolved({
              TAG: /* Ok */0,
              _0: Client__LSP$LanguageServerMule.getHandle(client$1)
            });
}

function stop(param) {
  var client = singleton.contents;
  if (typeof client === "number") {
    return $$Promise.resolved(undefined);
  }
  if (client.TAG === /* Connecting */0) {
    return $$Promise.flatMap(client._1, (function (param) {
                  return stop(undefined);
                }));
  }
  singleton.contents = /* Disconnected */0;
  console.log("[ connection ] severed");
  return Client__LSP$LanguageServerMule.destroy(client._0);
}

function sendRequest(globalStoragePath, request) {
  var client = singleton.contents;
  if (typeof client === "number") {
    return $$Promise.flatMapOk(start(globalStoragePath), (function (param) {
                  return sendRequest(globalStoragePath, request);
                }));
  }
  if (client.TAG !== /* Connecting */0) {
    return $$Promise.flatMapOk($$Promise.mapError(Client__LSP$LanguageServerMule.sendRequest(client._0, Request$Guabao.encode(request)), (function (e) {
                      return {
                              TAG: /* LSPClientError */1,
                              _0: e
                            };
                    })), (function (json) {
                  return $$Promise.resolved(decodeResponse(json));
                }));
  }
  var match = $$Promise.pending(undefined);
  client._0.push([
        request,
        match[1]
      ]);
  return match[0];
}

function onNotification(handler) {
  return new Vscode.Disposable(Chan$Guabao.on(notificationChan, handler));
}

function onError(handler) {
  return new Vscode.Disposable(Chan$Guabao.on(errorChan, handler));
}

function methodToString(x) {
  if (x.TAG === /* ViaStdIO */0) {
    return "ViaStdIO";
  } else {
    return "ViaTCP";
  }
}

var Module = {
  start: start,
  stop: stop,
  sendRequest: sendRequest,
  onNotification: onNotification,
  onError: onError,
  methodToString: methodToString
};

var Client;

var $$Error;

exports.Client = Client;
exports.$$Error = $$Error;
exports.Module = Module;
exports.start = start;
exports.stop = stop;
exports.sendRequest = sendRequest;
exports.onNotification = onNotification;
exports.onError = onError;
exports.methodToString = methodToString;
/* errorChan Not a pure module */
