// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Json = require("@glennsl/bs-json/lib/js/src/Json.bs.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Event$AgdaModeVscode = require("agda-mode-vscode/lib/js/src/Util/Event.bs.js");
var Process$AgdaModeVscode = require("agda-mode-vscode/lib/js/src/Process.bs.js");

function toString(e) {
  switch (e.TAG | 0) {
    case /* PathSearch */0 :
        return Curry._1(Process$AgdaModeVscode.PathSearch.$$Error.toString, e._0);
    case /* Validation */1 :
        return Curry._1(Process$AgdaModeVscode.Validation.$$Error.toString, e._0);
    case /* Process */2 :
        return Process$AgdaModeVscode.$$Error.toString(e._0);
    
  }
}

var $$Error = {
  toString: toString
};

function isConnected(connection) {
  return Curry._1(connection.process.isConnected, undefined);
}

function disconnect(connection) {
  return Curry._1(connection.process.disconnect, undefined);
}

function wire(connection) {
  var unfinishedMsg = {
    contents: undefined
  };
  Curry._1(connection.process.emitter.on, (function (data) {
          switch (data.TAG | 0) {
            case /* Stdout */0 :
                var data$1 = data._0;
                var unfinished = unfinishedMsg.contents;
                var augmented = unfinished !== undefined ? unfinished + data$1 : data$1;
                var result = Json.parse(augmented);
                if (result !== undefined) {
                  unfinishedMsg.contents = undefined;
                  Curry._1(connection.emitter.emit, {
                        TAG: 0,
                        _0: Caml_option.valFromOption(result),
                        [Symbol.for("name")]: "Ok"
                      });
                } else {
                  unfinishedMsg.contents = augmented;
                }
                return ;
            case /* Stderr */1 :
                console.warn(data._0);
                return ;
            case /* Error */2 :
                return Curry._1(connection.emitter.emit, {
                            TAG: 1,
                            _0: {
                              TAG: 2,
                              _0: data._0,
                              [Symbol.for("name")]: "Process"
                            },
                            [Symbol.for("name")]: "Error"
                          });
            
          }
        }));
  
}

function getGCLPath(fromConfig) {
  var storedPath = Belt_Option.mapWithDefault(Curry._1(fromConfig, undefined), "", (function (prim) {
          return prim.trim();
        }));
  if (storedPath === "" || storedPath === ".") {
    return $$Promise.mapError($$Promise.mapOk(Process$AgdaModeVscode.PathSearch.run("gcl"), (function (prim) {
                      return prim.trim();
                    })), (function (e) {
                  return {
                          TAG: 0,
                          _0: e,
                          [Symbol.for("name")]: "PathSearch"
                        };
                }));
  } else {
    return $$Promise.resolved({
                TAG: 0,
                _0: storedPath,
                [Symbol.for("name")]: "Ok"
              });
  }
}

function setGCLPath(toConfig, path) {
  return $$Promise.map(Curry._1(toConfig, path), (function (param) {
                return {
                        TAG: 0,
                        _0: path,
                        [Symbol.for("name")]: "Ok"
                      };
              }));
}

function validateGCLPath(path) {
  return $$Promise.mapError(Process$AgdaModeVscode.Validation.run(path + " --help", (function (output) {
                    if (/^GCL/.test(output)) {
                      return {
                              TAG: 0,
                              _0: path,
                              [Symbol.for("name")]: "Ok"
                            };
                    } else {
                      return {
                              TAG: 1,
                              _0: path,
                              [Symbol.for("name")]: "Error"
                            };
                    }
                  })), (function (e) {
                return {
                        TAG: 1,
                        _0: e,
                        [Symbol.for("name")]: "Validation"
                      };
              }));
}

function make(fromConfig, toConfig) {
  return $$Promise.tapOk($$Promise.mapOk($$Promise.flatMapOk($$Promise.flatMapOk(getGCLPath(fromConfig), validateGCLPath), (function (param) {
                        return setGCLPath(toConfig, param);
                      })), (function (path) {
                    var $$process = Process$AgdaModeVscode.make(path, []);
                    return {
                            path: path,
                            process: $$process,
                            emitter: Event$AgdaModeVscode.make(undefined)
                          };
                  })), wire);
}

function send(request, connection) {
  var promise = Curry._1(connection.emitter.once, undefined);
  var result = Curry._1(connection.process.send, request);
  if (result.TAG) {
    return $$Promise.resolved({
                TAG: 1,
                _0: {
                  TAG: 2,
                  _0: result._0,
                  [Symbol.for("name")]: "Process"
                },
                [Symbol.for("name")]: "Error"
              });
  } else {
    return promise;
  }
}

var Process;

exports.Process = Process;
exports.$$Error = $$Error;
exports.isConnected = isConnected;
exports.disconnect = disconnect;
exports.wire = wire;
exports.getGCLPath = getGCLPath;
exports.setGCLPath = setGCLPath;
exports.validateGCLPath = validateGCLPath;
exports.make = make;
exports.send = send;
/* Promise Not a pure module */
