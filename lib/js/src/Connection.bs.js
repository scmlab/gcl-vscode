// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Net = require("net");
var Json = require("@glennsl/bs-json/lib/js/src/Json.bs.js");
var Curry = require("bs-platform/lib/js/curry.js");
var VSCode = require("bs-vscode/lib/js/src/VSCode.bs.js");
var Vscode = require("vscode");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var LSP$Guacamole = require("./LSP.bs.js");
var Chan$Guacamole = require("./Util/Chan.bs.js");
var Request$Guacamole = require("./Request.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var Response$Guacamole = require("./Response.bs.js");
var VscodeLanguageclient = require("vscode-languageclient");
var Process$AgdaModeVscode = require("agda-mode-vscode/lib/js/src/Process.bs.js");

function toString(error) {
  switch (error.TAG | 0) {
    case /* CannotConnectViaStdIO */0 :
        var e = error._0;
        var match;
        switch (e.TAG | 0) {
          case /* ProcessHanging */0 :
              match = [
                "Process not responding when looking for \"" + (e._0 + "\""),
                "Please restart the process"
              ];
              break;
          case /* NotSupported */1 :
              match = [
                "Auto search failed",
                "currently auto path searching is not supported on " + e._0
              ];
              break;
          case /* NotFound */2 :
              match = [
                "Auto search failed when looking for \"" + (e._0 + "\""),
                "If you know where the executable of GCL is located, please fill it in \"guacamole.gclPath\" in the Settings.\nThe system responded with the following message " + e._1
              ];
              break;
          
        }
        return [
                "Cannot locate \"gcl\"",
                match[1] + "\nPlease make sure that the executable is in the path"
              ];
    case /* CannotConnectViaTCP */1 :
        return [
                "Cannot connect with the server",
                "Please enter \":main -d\" in ghci"
              ];
    case /* ConnectionError */2 :
        var exn = error._0;
        var isECONNREFUSED = Belt_Option.mapWithDefault(exn.message, false, (function (param) {
                return param.startsWith("connect ECONNREFUSED");
              }));
        if (isECONNREFUSED) {
          return [
                  "LSP Connection Error",
                  "Please enter \":main -d\" in ghci"
                ];
        } else {
          return [
                  "LSP Client Error",
                  Belt_Option.getWithDefault(exn.message, "")
                ];
        }
    case /* CannotSendRequest */3 :
        return [
                "PANIC: Cannot send request",
                "Please file an issue\n" + Belt_Option.getWithDefault(error._0.message, "")
              ];
    case /* CannotDecodeResponse */4 :
        return [
                "PANIC: Cannot decode response",
                "Please file an issue\n\n" + error._0 + "\n" + Json.stringify(error._1)
              ];
    
  }
}

var $$Error = {
  toString: toString
};

function probe(name) {
  return $$Promise.mapError($$Promise.mapOk(Process$AgdaModeVscode.PathSearch.run(name), (function (path) {
                    return {
                            TAG: 0,
                            _0: name,
                            _1: path.trim(),
                            [Symbol.for("name")]: "ViaStdIO"
                          };
                  })), (function (e) {
                return {
                        TAG: 0,
                        _0: e,
                        [Symbol.for("name")]: "CannotConnectViaStdIO"
                      };
              }));
}

function probe$1(port) {
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  var socket = Net.connect(port, (function (param) {
          return Curry._1(resolve, {
                      TAG: 0,
                      _0: undefined,
                      [Symbol.for("name")]: "Ok"
                    });
        }));
  socket.on("error", (function (exn) {
          return Curry._1(resolve, {
                      TAG: 1,
                      _0: {
                        TAG: 1,
                        _0: exn,
                        [Symbol.for("name")]: "CannotConnectViaTCP"
                      },
                      [Symbol.for("name")]: "Error"
                    });
        }));
  return $$Promise.mapOk(match[0], (function (param) {
                socket.destroy();
                return {
                        TAG: 1,
                        _0: port,
                        [Symbol.for("name")]: "ViaTCP"
                      };
              }));
}

var errorChan = Chan$Guacamole.make(undefined);

var dataChan = Chan$Guacamole.make(undefined);

function onError(callback) {
  return new Vscode.Disposable(Chan$Guacamole.on(errorChan, (function (e) {
                    return Curry._1(callback, {
                                TAG: 2,
                                _0: e,
                                [Symbol.for("name")]: "ConnectionError"
                              });
                  })));
}

function sendRequest(self, data) {
  return $$Promise.mapError($$Promise.flatMapOk($$Promise.Js.toResult(self.client.onReady()), (function (param) {
                    return $$Promise.Js.toResult(self.client.sendRequest("guacamole", data));
                  })), (function (exn) {
                return {
                        TAG: 3,
                        _0: exn,
                        [Symbol.for("name")]: "CannotSendRequest"
                      };
              }));
}

function make(method) {
  var serverOptions;
  serverOptions = method.TAG === /* ViaStdIO */0 ? LSP$Guacamole.ServerOptions.makeWithCommand(method._0) : LSP$Guacamole.ServerOptions.makeWithStreamInfo(method._0);
  var documentSelector = [VSCode.StringOr.others({
          language: "guacamole",
          pattern: undefined,
          scheme: "file"
        })];
  var synchronize = Vscode.workspace.createFileSystemWatcher('**/.clientrc', false, false, false);
  var errorHandler = LSP$Guacamole.ErrorHandler.make((function (exn, _msg, _count) {
          Chan$Guacamole.emit(errorChan, exn);
          return /* Shutdown */1;
        }), (function (param) {
          return /* DoNotRestart */0;
        }));
  var clientOptions = LSP$Guacamole.LanguageClientOptions.make(documentSelector, synchronize, errorHandler);
  var languageClient = new VscodeLanguageclient.LanguageClient("guacamoleLanguageServer", "Guacamole Language Server", serverOptions, clientOptions);
  var self_subscription = languageClient.start();
  var self = {
    client: languageClient,
    subscription: self_subscription,
    method: method
  };
  return $$Promise.mapError($$Promise.map($$Promise.race({
                      hd: $$Promise.Js.toResult(languageClient.onReady()),
                      tl: {
                        hd: $$Promise.map(Chan$Guacamole.once(errorChan), (function (err) {
                                return {
                                        TAG: 1,
                                        _0: err,
                                        [Symbol.for("name")]: "Error"
                                      };
                              })),
                        tl: /* [] */0
                      }
                    }), (function (result) {
                    if (result.TAG !== /* Ok */0) {
                      return {
                              TAG: 1,
                              _0: result._0,
                              [Symbol.for("name")]: "Error"
                            };
                    }
                    languageClient.onNotification("guacamole", (function (json) {
                            return Chan$Guacamole.emit(dataChan, json);
                          }));
                    return {
                            TAG: 0,
                            _0: self,
                            [Symbol.for("name")]: "Ok"
                          };
                  })), (function (e) {
                return {
                        TAG: 2,
                        _0: e,
                        [Symbol.for("name")]: "ConnectionError"
                      };
              }));
}

function probe$2(tryTCP) {
  var name = "gcl";
  if (tryTCP) {
    return $$Promise.flatMapError(probe$1(3000), (function (param) {
                  return probe(name);
                }));
  } else {
    return probe(name);
  }
}

var singleton = {
  contents: /* Disconnected */0
};

function getPendingRequests(param) {
  var match = singleton.contents;
  if (typeof match === "number") {
    return [];
  } else if (match.TAG === /* Connecting */0) {
    return match._0;
  } else {
    return [];
  }
}

function decodeResponse(json) {
  var response;
  try {
    response = Response$Guacamole.decode(json);
  }
  catch (raw_msg){
    var msg = Caml_js_exceptions.internalToOCamlException(raw_msg);
    if (msg.RE_EXN_ID === Json_decode.DecodeError) {
      return {
              TAG: 1,
              _0: {
                TAG: 4,
                _0: msg._1,
                _1: json,
                [Symbol.for("name")]: "CannotDecodeResponse"
              },
              [Symbol.for("name")]: "Error"
            };
    }
    throw msg;
  }
  return {
          TAG: 0,
          _0: response,
          [Symbol.for("name")]: "Ok"
        };
}

function make$1(tryTCP) {
  var client = singleton.contents;
  if (typeof client !== "number") {
    if (client.TAG === /* Connecting */0) {
      return client._1;
    } else {
      return $$Promise.resolved({
                  TAG: 0,
                  _0: client._0.method,
                  [Symbol.for("name")]: "Ok"
                });
    }
  }
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  singleton.contents = {
    TAG: 0,
    _0: [],
    _1: match[0],
    [Symbol.for("name")]: "Connecting"
  };
  return $$Promise.map($$Promise.flatMapOk(probe$2(tryTCP), make), (function (result) {
                if (result.TAG === /* Ok */0) {
                  var client = result._0;
                  singleton.contents = {
                    TAG: 1,
                    _0: client,
                    [Symbol.for("name")]: "Connected"
                  };
                  Belt_Array.forEach(getPendingRequests(undefined), (function (param) {
                          return $$Promise.get($$Promise.flatMapOk(sendRequest(client, Request$Guacamole.encode(param[0])), (function (json) {
                                            return $$Promise.resolved(decodeResponse(json));
                                          })), param[1]);
                        }));
                  Curry._1(resolve, {
                        TAG: 0,
                        _0: client.method,
                        [Symbol.for("name")]: "Ok"
                      });
                  return {
                          TAG: 0,
                          _0: client.method,
                          [Symbol.for("name")]: "Ok"
                        };
                }
                var error = result._0;
                singleton.contents = /* Disconnected */0;
                Belt_Array.forEach(getPendingRequests(undefined), (function (param) {
                        return Curry._1(param[1], {
                                    TAG: 1,
                                    _0: error,
                                    [Symbol.for("name")]: "Error"
                                  });
                      }));
                Curry._1(resolve, {
                      TAG: 1,
                      _0: error,
                      [Symbol.for("name")]: "Error"
                    });
                return {
                        TAG: 1,
                        _0: error,
                        [Symbol.for("name")]: "Error"
                      };
              }));
}

function destroy(param) {
  var client = singleton.contents;
  if (typeof client === "number") {
    return $$Promise.resolved(undefined);
  }
  if (client.TAG === /* Connecting */0) {
    return $$Promise.flatMap(client._1, (function (param) {
                  return destroy(undefined);
                }));
  }
  singleton.contents = /* Disconnected */0;
  var self = client._0;
  self.subscription.dispose();
  return $$Promise.map($$Promise.Js.toResult(self.client.stop()), (function (param) {
                
              }));
}

function sendRequest$1(tryTCP, request) {
  var client = singleton.contents;
  if (typeof client === "number") {
    return $$Promise.flatMapOk(make$1(tryTCP), (function (param) {
                  return sendRequest$1(tryTCP, request);
                }));
  }
  if (client.TAG !== /* Connecting */0) {
    return $$Promise.flatMapOk(sendRequest(client._0, Request$Guacamole.encode(request)), (function (json) {
                  return $$Promise.resolved(decodeResponse(json));
                }));
  }
  var match = $$Promise.pending(undefined);
  client._0.push([
        request,
        match[1]
      ]);
  return match[0];
}

function onResponse(handler) {
  return new Vscode.Disposable(Chan$Guacamole.on(dataChan, (function (json) {
                    return Curry._1(handler, decodeResponse(json));
                  })));
}

function getMethod(param) {
  var client = singleton.contents;
  if (typeof client === "number" || client.TAG === /* Connecting */0) {
    return ;
  } else {
    return client._0.method;
  }
}

var Module = {
  make: make$1,
  destroy: destroy,
  sendRequest: sendRequest$1,
  onResponse: onResponse,
  onError: onError,
  getMethod: getMethod
};

exports.$$Error = $$Error;
exports.Module = Module;
exports.make = make$1;
exports.destroy = destroy;
exports.sendRequest = sendRequest$1;
exports.onResponse = onResponse;
exports.onError = onError;
exports.getMethod = getMethod;
/* errorChan Not a pure module */
