// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Vscode = require("vscode");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var Json_encode = require("@glennsl/bs-json/lib/js/src/Json_encode.bs.js");
var Util$Guacamole = require("./Util.bs.js");
var Caml_splice_call = require("bs-platform/lib/js/caml_splice_call.js");

function toPoint(param) {
  return new Vscode.Position(param._1 - 1 | 0, param._2 - 1 | 0);
}

function fromPoint(point, filepath) {
  return {
          _0: filepath,
          _1: point.line + 1 | 0,
          _2: point.character + 1 | 0,
          [Symbol.for("name")]: "Pos"
        };
}

function toString(param) {
  return String(param._1) + (":" + String(param._2));
}

function translate(by, param) {
  return {
          _0: param._0,
          _1: param._1 + by._1 | 0,
          _2: param._2 + by._2 | 0,
          [Symbol.for("name")]: "Pos"
        };
}

function translateBy(y, x, param) {
  return {
          _0: param._0,
          _1: param._1 + y | 0,
          _2: param._2 + x | 0,
          [Symbol.for("name")]: "Pos"
        };
}

function decode(param) {
  return Json_decode.map((function (param) {
                return {
                        _0: param[0],
                        _1: param[1],
                        _2: param[2],
                        [Symbol.for("name")]: "Pos"
                      };
              }), (function (param) {
                return Json_decode.tuple4(Json_decode.string, Json_decode.$$int, Json_decode.$$int, Json_decode.$$int, param);
              }), param);
}

function encode(param) {
  return Json_encode.tuple4((function (prim) {
                return prim;
              }), (function (prim) {
                return prim;
              }), (function (prim) {
                return prim;
              }), (function (prim) {
                return prim;
              }), [
              param._0,
              param._1,
              param._2,
              0
            ]);
}

var Pos = {
  toPoint: toPoint,
  fromPoint: fromPoint,
  toString: toString,
  translate: translate,
  translateBy: translateBy,
  decode: decode,
  encode: encode
};

function toRange(param) {
  if (!param) {
    return new Vscode.Range(new Vscode.Position(0, 0), new Vscode.Position(0, 0));
  }
  var match = param._1;
  return new Vscode.Range(toPoint(param._0), new Vscode.Position(match._1 - 1 | 0, match._2));
}

function toString$1(param) {
  if (param) {
    return toString(param._0) + ("-" + toString(param._1));
  } else {
    return "NoLoc";
  }
}

function translate$1(by, param) {
  if (!param) {
    return by;
  }
  var y = param._1;
  var x = param._0;
  if (by) {
    return {
            _0: translate(x, by._0),
            _1: translate(y, by._1),
            [Symbol.for("name")]: "Loc"
          };
  } else {
    return {
            _0: x,
            _1: y,
            [Symbol.for("name")]: "Loc"
          };
  }
}

function translateBy$1(startY, startX, endY, endX, param) {
  if (param) {
    return {
            _0: translateBy(startY, startX, param._0),
            _1: translateBy(endY, endX, param._1),
            [Symbol.for("name")]: "Loc"
          };
  } else {
    return {
            _0: {
              _0: "",
              _1: startY,
              _2: startX,
              [Symbol.for("name")]: "Pos"
            },
            _1: {
              _0: "",
              _1: endY,
              _2: endX,
              [Symbol.for("name")]: "Pos"
            },
            [Symbol.for("name")]: "Loc"
          };
  }
}

var decode$1 = Util$Guacamole.Decode.sum(function (tag) {
      switch (tag) {
        case "Loc" :
            return {
                    TAG: 0,
                    _0: (function (param) {
                        return Json_decode.map((function (param) {
                                      return {
                                              _0: param[0],
                                              _1: param[1],
                                              [Symbol.for("name")]: "Loc"
                                            };
                                    }), (function (param) {
                                      return Json_decode.pair(decode, decode, param);
                                    }), param);
                      }),
                    [Symbol.for("name")]: "Contents"
                  };
        case "NoLoc" :
            return {
                    TAG: 1,
                    _0: (function (param) {
                        return /* NoLoc */0;
                      }),
                    [Symbol.for("name")]: "TagOnly"
                  };
        default:
          throw {
                RE_EXN_ID: Json_decode.DecodeError,
                _1: "[Loc] Unknown constructor: " + tag,
                Error: new Error()
              };
      }
    });

function encode$1(param) {
  if (param) {
    return Json_encode.object_({
                hd: [
                  "tag",
                  "Loc"
                ],
                tl: {
                  hd: [
                    "contents",
                    Json_encode.pair(encode, encode, [
                          param._0,
                          param._1
                        ])
                  ],
                  tl: /* [] */0
                }
              });
  } else {
    return Json_encode.object_({
                hd: [
                  "tag",
                  "NoLoc"
                ],
                tl: /* [] */0
              });
  }
}

var Loc = {
  toRange: toRange,
  toString: toString$1,
  translate: translate$1,
  translateBy: translateBy$1,
  decode: decode$1,
  encode: encode$1
};

function $$return(x) {
  return {
          TAG: 1,
          _0: x,
          [Symbol.for("name")]: "Complete"
        };
}

function flatMap(x, f) {
  if (x.TAG) {
    return Curry._1(f, x._0);
  }
  var g = x._0;
  return {
          TAG: 0,
          _0: (function (x) {
              return flatMap(Curry._1(g, x), f);
            }),
          [Symbol.for("name")]: "Expect"
        };
}

var $$var = {
  TAG: 0,
  _0: (function (x) {
      return {
              TAG: 1,
              _0: x,
              [Symbol.for("name")]: "Complete"
            };
    }),
  [Symbol.for("name")]: "Expect"
};

var VarArg = {
  $$return: $$return,
  flatMap: flatMap,
  $$var: $$var
};

function toString$2(i) {
  switch (i.TAG | 0) {
    case /* Num */0 :
        return String(i._0);
    case /* Bool */1 :
        if (i._0) {
          return "True";
        } else {
          return "False";
        }
    case /* Unknown */2 :
        return JSON.stringify(i._0);
    
  }
}

function decode$2(json) {
  return Util$Guacamole.Decode.sum(function (param) {
                switch (param) {
                  case "Bol" :
                      return {
                              TAG: 0,
                              _0: (function (param) {
                                  return Json_decode.map((function (x) {
                                                return {
                                                        TAG: 1,
                                                        _0: x,
                                                        [Symbol.for("name")]: "Bool"
                                                      };
                                              }), Json_decode.bool, param);
                                }),
                              [Symbol.for("name")]: "Contents"
                            };
                  case "Num" :
                      return {
                              TAG: 0,
                              _0: (function (param) {
                                  return Json_decode.map((function (x) {
                                                return {
                                                        TAG: 0,
                                                        _0: x,
                                                        [Symbol.for("name")]: "Num"
                                                      };
                                              }), Json_decode.$$int, param);
                                }),
                              [Symbol.for("name")]: "Contents"
                            };
                  default:
                    return {
                            TAG: 0,
                            _0: (function (json) {
                                return {
                                        TAG: 2,
                                        _0: json,
                                        [Symbol.for("name")]: "Unknown"
                                      };
                              }),
                            [Symbol.for("name")]: "Contents"
                          };
                }
              })(json);
}

function encode$2(i) {
  switch (i.TAG | 0) {
    case /* Num */0 :
        return Json_encode.object_({
                    hd: [
                      "tag",
                      "Num"
                    ],
                    tl: {
                      hd: [
                        "contents",
                        i._0
                      ],
                      tl: /* [] */0
                    }
                  });
    case /* Bool */1 :
        return Json_encode.object_({
                    hd: [
                      "tag",
                      "Bol"
                    ],
                    tl: {
                      hd: [
                        "contents",
                        i._0
                      ],
                      tl: /* [] */0
                    }
                  });
    case /* Unknown */2 :
        return Json_encode.object_({
                    hd: [
                      "tag",
                      "Num"
                    ],
                    tl: {
                      hd: [
                        "contents",
                        42
                      ],
                      tl: /* [] */0
                    }
                  });
    
  }
}

var Lit = {
  toString: toString$2,
  decode: decode$2,
  encode: encode$2
};

function toString$3(string) {
  if (typeof string !== "number") {
    return string._0;
  }
  switch (string) {
    case /* EQ */0 :
        return "=";
    case /* NEQ */1 :
        return "≠";
    case /* LTE */2 :
        return "≤";
    case /* GTE */3 :
        return "≥";
    case /* LT */4 :
        return "<";
    case /* GT */5 :
        return ">";
    case /* Implies */6 :
        return "→";
    case /* Conj */7 :
        return "∧";
    case /* Disj */8 :
        return "∨";
    case /* Neg */9 :
        return "¬";
    case /* Add */10 :
        return "+";
    case /* Sub */11 :
        return "-";
    case /* Mul */12 :
        return "×";
    case /* Div */13 :
        return "÷";
    case /* Mod */14 :
        return "%";
    
  }
}

function decode$3(param) {
  return Json_decode.map((function (string) {
                switch (string) {
                  case "Add" :
                      return /* Add */10;
                  case "Conj" :
                      return /* Conj */7;
                  case "Disj" :
                      return /* Disj */8;
                  case "Div" :
                      return /* Div */13;
                  case "EQ" :
                      return /* EQ */0;
                  case "GT" :
                      return /* GT */5;
                  case "GTE" :
                      return /* GTE */3;
                  case "Implies" :
                      return /* Implies */6;
                  case "LT" :
                      return /* LT */4;
                  case "LTE" :
                      return /* LTE */2;
                  case "Mod" :
                      return /* Mod */14;
                  case "Mul" :
                      return /* Mul */12;
                  case "NEQ" :
                      return /* NEQ */1;
                  case "Neg" :
                      return /* Neg */9;
                  case "Sub" :
                      return /* Sub */11;
                  default:
                    return {
                            _0: string,
                            [Symbol.for("name")]: "Unknown"
                          };
                }
              }), Json_decode.string, param);
}

function encode$3(x) {
  if (typeof x !== "number") {
    return x._0;
  }
  switch (x) {
    case /* EQ */0 :
        return "EQ";
    case /* NEQ */1 :
        return "NEQ";
    case /* LTE */2 :
        return "LTE";
    case /* GTE */3 :
        return "GTE";
    case /* LT */4 :
        return "LT";
    case /* GT */5 :
        return "GT";
    case /* Implies */6 :
        return "Implies";
    case /* Conj */7 :
        return "Conj";
    case /* Disj */8 :
        return "Disj";
    case /* Neg */9 :
        return "Neg";
    case /* Add */10 :
        return "Add";
    case /* Sub */11 :
        return "Sub";
    case /* Mul */12 :
        return "Mul";
    case /* Div */13 :
        return "Div";
    case /* Mod */14 :
        return "Mod";
    
  }
}

var Op = {
  toString: toString$3,
  decode: decode$3,
  encode: encode$3
};

function toString$4(param) {
  return param._0;
}

function decode$4(param) {
  return Json_decode.map((function (param) {
                return {
                        _0: param[0],
                        _1: param[1],
                        [Symbol.for("name")]: "Name"
                      };
              }), (function (param) {
                return Json_decode.pair(Json_decode.string, decode$1, param);
              }), param);
}

function encode$4(param) {
  return Json_encode.pair((function (prim) {
                return prim;
              }), encode$1, [
              param._0,
              param._1
            ]);
}

var Name = {
  toString: toString$4,
  decode: decode$4,
  encode: encode$4
};

function locOf(loc) {
  switch (loc.TAG | 0) {
    case /* App */4 :
    case /* Lam */5 :
        return loc._2;
    case /* Hole */6 :
        return loc._0;
    case /* Quant */7 :
        return loc._4;
    case /* Subst */8 :
    case /* Unknown */9 :
        return /* NoLoc */0;
    default:
      return loc._1;
  }
}

function negate(x) {
  return {
          TAG: 4,
          _0: {
            TAG: 3,
            _0: /* Neg */9,
            _1: /* NoLoc */0,
            [Symbol.for("name")]: "Op"
          },
          _1: x,
          _2: /* NoLoc */0,
          [Symbol.for("name")]: "App"
        };
}

function disj(x, y) {
  return {
          TAG: 4,
          _0: {
            TAG: 4,
            _0: {
              TAG: 3,
              _0: /* Disj */8,
              _1: /* NoLoc */0,
              [Symbol.for("name")]: "Op"
            },
            _1: x,
            _2: /* NoLoc */0,
            [Symbol.for("name")]: "App"
          },
          _1: y,
          _2: /* NoLoc */0,
          [Symbol.for("name")]: "App"
        };
}

function conj(x, y) {
  return {
          TAG: 4,
          _0: {
            TAG: 4,
            _0: {
              TAG: 3,
              _0: /* Conj */7,
              _1: /* NoLoc */0,
              [Symbol.for("name")]: "Op"
            },
            _1: x,
            _2: /* NoLoc */0,
            [Symbol.for("name")]: "App"
          },
          _1: y,
          _2: /* NoLoc */0,
          [Symbol.for("name")]: "App"
        };
}

function disjunct$prime(param) {
  if (!param) {
    return {
            TAG: 0,
            _0: {
              TAG: 1,
              _0: true,
              [Symbol.for("name")]: "Bool"
            },
            _1: /* NoLoc */0,
            [Symbol.for("name")]: "Lit"
          };
  }
  var xs = param.tl;
  var x = param.hd;
  if (xs) {
    return disj(x, disjunct$prime(xs));
  } else {
    return x;
  }
}

function conjunct$prime(param) {
  if (!param) {
    return {
            TAG: 0,
            _0: {
              TAG: 1,
              _0: false,
              [Symbol.for("name")]: "Bool"
            },
            _1: /* NoLoc */0,
            [Symbol.for("name")]: "Lit"
          };
  }
  var xs = param.tl;
  var x = param.hd;
  if (xs) {
    return conj(x, conjunct$prime(xs));
  } else {
    return x;
  }
}

function disjunct(xs) {
  return disjunct$prime(Belt_List.fromArray(xs));
}

function conjunct(xs) {
  return conjunct$prime(Belt_List.fromArray(xs));
}

function decode$5(json) {
  return Util$Guacamole.Decode.sum(function (param) {
                switch (param) {
                  case "App" :
                      return {
                              TAG: 0,
                              _0: (function (param) {
                                  return Json_decode.map((function (param) {
                                                return {
                                                        TAG: 4,
                                                        _0: param[0],
                                                        _1: param[1],
                                                        _2: param[2],
                                                        [Symbol.for("name")]: "App"
                                                      };
                                              }), (function (param) {
                                                return Json_decode.tuple3(decode$5, decode$5, decode$1, param);
                                              }), param);
                                }),
                              [Symbol.for("name")]: "Contents"
                            };
                  case "Const" :
                      return {
                              TAG: 0,
                              _0: (function (param) {
                                  return Json_decode.map((function (param) {
                                                return {
                                                        TAG: 2,
                                                        _0: param[0],
                                                        _1: param[1],
                                                        [Symbol.for("name")]: "Const"
                                                      };
                                              }), (function (param) {
                                                return Json_decode.pair(decode$4, decode$1, param);
                                              }), param);
                                }),
                              [Symbol.for("name")]: "Contents"
                            };
                  case "Hole" :
                      return {
                              TAG: 0,
                              _0: (function (param) {
                                  return Json_decode.map((function (r) {
                                                return {
                                                        TAG: 6,
                                                        _0: r,
                                                        [Symbol.for("name")]: "Hole"
                                                      };
                                              }), decode$1, param);
                                }),
                              [Symbol.for("name")]: "Contents"
                            };
                  case "Lam" :
                      return {
                              TAG: 0,
                              _0: (function (param) {
                                  return Json_decode.map((function (param) {
                                                return {
                                                        TAG: 5,
                                                        _0: param[0],
                                                        _1: param[1],
                                                        _2: param[2],
                                                        [Symbol.for("name")]: "Lam"
                                                      };
                                              }), (function (param) {
                                                return Json_decode.tuple3(Json_decode.string, decode$5, decode$1, param);
                                              }), param);
                                }),
                              [Symbol.for("name")]: "Contents"
                            };
                  case "Lit" :
                      return {
                              TAG: 0,
                              _0: (function (param) {
                                  return Json_decode.map((function (param) {
                                                return {
                                                        TAG: 0,
                                                        _0: param[0],
                                                        _1: param[1],
                                                        [Symbol.for("name")]: "Lit"
                                                      };
                                              }), (function (param) {
                                                return Json_decode.pair(decode$2, decode$1, param);
                                              }), param);
                                }),
                              [Symbol.for("name")]: "Contents"
                            };
                  case "Op" :
                      return {
                              TAG: 0,
                              _0: (function (param) {
                                  return Json_decode.map((function (param) {
                                                return {
                                                        TAG: 3,
                                                        _0: param[0],
                                                        _1: param[1],
                                                        [Symbol.for("name")]: "Op"
                                                      };
                                              }), (function (param) {
                                                return Json_decode.pair(decode$3, decode$1, param);
                                              }), param);
                                }),
                              [Symbol.for("name")]: "Contents"
                            };
                  case "Quant" :
                      return {
                              TAG: 0,
                              _0: (function (param) {
                                  return Json_decode.map((function (param) {
                                                return {
                                                        TAG: 7,
                                                        _0: param[0],
                                                        _1: param[1],
                                                        _2: param[2],
                                                        _3: param[3],
                                                        _4: param[4],
                                                        [Symbol.for("name")]: "Quant"
                                                      };
                                              }), (function (param) {
                                                return Util$Guacamole.Decode.tuple5(decode$5, (function (param) {
                                                              return Json_decode.array(decode$4, param);
                                                            }), decode$5, decode$5, decode$1, param);
                                              }), param);
                                }),
                              [Symbol.for("name")]: "Contents"
                            };
                  case "Subst" :
                      return {
                              TAG: 0,
                              _0: (function (param) {
                                  return Json_decode.map((function (param) {
                                                return {
                                                        TAG: 8,
                                                        _0: param[0],
                                                        _1: param[1],
                                                        [Symbol.for("name")]: "Subst"
                                                      };
                                              }), (function (param) {
                                                return Json_decode.pair(decode$5, decodeSubst, param);
                                              }), param);
                                }),
                              [Symbol.for("name")]: "Contents"
                            };
                  case "Var" :
                      return {
                              TAG: 0,
                              _0: (function (param) {
                                  return Json_decode.map((function (param) {
                                                return {
                                                        TAG: 1,
                                                        _0: param[0],
                                                        _1: param[1],
                                                        [Symbol.for("name")]: "Var"
                                                      };
                                              }), (function (param) {
                                                return Json_decode.pair(decode$4, decode$1, param);
                                              }), param);
                                }),
                              [Symbol.for("name")]: "Contents"
                            };
                  default:
                    return {
                            TAG: 0,
                            _0: (function (json) {
                                return {
                                        TAG: 9,
                                        _0: json,
                                        [Symbol.for("name")]: "Unknown"
                                      };
                              }),
                            [Symbol.for("name")]: "Contents"
                          };
                }
              })(json);
}

function decodeSubst(json) {
  return Json_decode.dict(decode$5, json);
}

function encode$5(loc) {
  switch (loc.TAG | 0) {
    case /* Lit */0 :
        return Json_encode.object_({
                    hd: [
                      "tag",
                      "Lit"
                    ],
                    tl: {
                      hd: [
                        "contents",
                        Json_encode.pair(encode$2, encode$1, [
                              loc._0,
                              loc._1
                            ])
                      ],
                      tl: /* [] */0
                    }
                  });
    case /* Var */1 :
        return Json_encode.object_({
                    hd: [
                      "tag",
                      "Var"
                    ],
                    tl: {
                      hd: [
                        "contents",
                        Json_encode.pair(encode$4, encode$1, [
                              loc._0,
                              loc._1
                            ])
                      ],
                      tl: /* [] */0
                    }
                  });
    case /* Const */2 :
        return Json_encode.object_({
                    hd: [
                      "tag",
                      "Const"
                    ],
                    tl: {
                      hd: [
                        "contents",
                        Json_encode.pair(encode$4, encode$1, [
                              loc._0,
                              loc._1
                            ])
                      ],
                      tl: /* [] */0
                    }
                  });
    case /* Op */3 :
        return Json_encode.object_({
                    hd: [
                      "tag",
                      "Op"
                    ],
                    tl: {
                      hd: [
                        "contents",
                        Json_encode.pair(encode$3, encode$1, [
                              loc._0,
                              loc._1
                            ])
                      ],
                      tl: /* [] */0
                    }
                  });
    case /* App */4 :
        return Json_encode.object_({
                    hd: [
                      "tag",
                      "App"
                    ],
                    tl: {
                      hd: [
                        "contents",
                        Json_encode.tuple3(encode$5, encode$5, encode$1, [
                              loc._0,
                              loc._1,
                              loc._2
                            ])
                      ],
                      tl: /* [] */0
                    }
                  });
    case /* Lam */5 :
        return Json_encode.object_({
                    hd: [
                      "tag",
                      "Lam"
                    ],
                    tl: {
                      hd: [
                        "contents",
                        Json_encode.tuple3((function (prim) {
                                return prim;
                              }), encode$5, encode$1, [
                              loc._0,
                              loc._1,
                              loc._2
                            ])
                      ],
                      tl: /* [] */0
                    }
                  });
    case /* Hole */6 :
        return Json_encode.object_({
                    hd: [
                      "tag",
                      "Hole"
                    ],
                    tl: {
                      hd: [
                        "contents",
                        encode$1(loc._0)
                      ],
                      tl: /* [] */0
                    }
                  });
    case /* Quant */7 :
        return Json_encode.object_({
                    hd: [
                      "tag",
                      "Quant"
                    ],
                    tl: {
                      hd: [
                        "contents",
                        Util$Guacamole.Encode.tuple5(encode$5, (function (param) {
                                return Json_encode.array(encode$4, param);
                              }), encode$5, encode$5, encode$1, [
                              loc._0,
                              loc._1,
                              loc._2,
                              loc._3,
                              loc._4
                            ])
                      ],
                      tl: /* [] */0
                    }
                  });
    case /* Subst */8 :
        return Json_encode.object_({
                    hd: [
                      "tag",
                      "Subst"
                    ],
                    tl: {
                      hd: [
                        "contents",
                        Json_encode.pair(encode$5, encodeSubst, [
                              loc._0,
                              loc._1
                            ])
                      ],
                      tl: /* [] */0
                    }
                  });
    case /* Unknown */9 :
        return Json_encode.object_({
                    hd: [
                      "tag",
                      "Hole"
                    ],
                    tl: {
                      hd: [
                        "contents",
                        encode$1(/* NoLoc */0)
                      ],
                      tl: /* [] */0
                    }
                  });
    
  }
}

function encodeSubst(json) {
  return Json_encode.dict(encode$5, json);
}

function classify(param) {
  if (typeof param !== "number") {
    return {
            TAG: 0,
            _0: 9,
            [Symbol.for("name")]: "InfixL"
          };
  }
  switch (param) {
    case /* EQ */0 :
        return {
                TAG: 2,
                _0: 5,
                [Symbol.for("name")]: "Infix"
              };
    case /* NEQ */1 :
    case /* LTE */2 :
    case /* GTE */3 :
    case /* LT */4 :
    case /* GT */5 :
        return {
                TAG: 2,
                _0: 6,
                [Symbol.for("name")]: "Infix"
              };
    case /* Implies */6 :
        return {
                TAG: 1,
                _0: 1,
                [Symbol.for("name")]: "InfixR"
              };
    case /* Conj */7 :
        return {
                TAG: 0,
                _0: 3,
                [Symbol.for("name")]: "InfixL"
              };
    case /* Disj */8 :
        return {
                TAG: 0,
                _0: 2,
                [Symbol.for("name")]: "InfixL"
              };
    case /* Neg */9 :
        return {
                TAG: 3,
                _0: 4,
                [Symbol.for("name")]: "Prefix"
              };
    case /* Add */10 :
    case /* Sub */11 :
        return {
                TAG: 0,
                _0: 7,
                [Symbol.for("name")]: "InfixL"
              };
    case /* Mul */12 :
    case /* Div */13 :
        return {
                TAG: 0,
                _0: 8,
                [Symbol.for("name")]: "InfixL"
              };
    case /* Mod */14 :
        return {
                TAG: 0,
                _0: 9,
                [Symbol.for("name")]: "InfixL"
              };
    
  }
}

function parensIf(p, s) {
  if (p) {
    return "(" + (s + ")");
  } else {
    return s;
  }
}

function handleOperator(n, op) {
  var m = classify(op);
  switch (m.TAG | 0) {
    case /* InfixL */0 :
        var m$1 = m._0;
        return flatMap($$var, (function (p) {
                      return flatMap($$var, (function (q) {
                                    return {
                                            TAG: 1,
                                            _0: parensIf(n > m$1, toString$5(m$1, p) + (" " + (toString$3(op) + (" " + toString$5(m$1 + 1 | 0, q))))),
                                            [Symbol.for("name")]: "Complete"
                                          };
                                  }));
                    }));
    case /* InfixR */1 :
        var m$2 = m._0;
        return flatMap($$var, (function (p) {
                      return flatMap($$var, (function (q) {
                                    return {
                                            TAG: 1,
                                            _0: parensIf(n > m$2, toString$5(m$2 + 1 | 0, p) + (" " + (toString$3(op) + (" " + toString$5(m$2, q))))),
                                            [Symbol.for("name")]: "Complete"
                                          };
                                  }));
                    }));
    case /* Infix */2 :
        var m$3 = m._0;
        return flatMap($$var, (function (p) {
                      return flatMap($$var, (function (q) {
                                    return {
                                            TAG: 1,
                                            _0: parensIf(n > m$3, toString$5(m$3 + 1 | 0, p) + (" " + (toString$3(op) + (" " + toString$5(m$3 + 1 | 0, q))))),
                                            [Symbol.for("name")]: "Complete"
                                          };
                                  }));
                    }));
    case /* Prefix */3 :
        var m$4 = m._0;
        return flatMap($$var, (function (p) {
                      return {
                              TAG: 1,
                              _0: parensIf(n > m$4, toString$3(op) + (" " + toString$5(m$4, p))),
                              [Symbol.for("name")]: "Complete"
                            };
                    }));
    case /* Postfix */4 :
        var m$5 = m._0;
        return flatMap($$var, (function (p) {
                      return {
                              TAG: 1,
                              _0: parensIf(n > m$5, toString$5(m$5, p) + (" " + toString$3(op))),
                              [Symbol.for("name")]: "Complete"
                            };
                    }));
    
  }
}

function handleExpr(n, _x) {
  while(true) {
    var x = _x;
    switch (x.TAG | 0) {
      case /* Lit */0 :
          return {
                  TAG: 1,
                  _0: toString$2(x._0),
                  [Symbol.for("name")]: "Complete"
                };
      case /* Var */1 :
      case /* Const */2 :
          return {
                  TAG: 1,
                  _0: toString$4(x._0),
                  [Symbol.for("name")]: "Complete"
                };
      case /* Op */3 :
          return handleOperator(n, x._0);
      case /* App */4 :
          var q = x._1;
          var f = handleExpr(n, x._0);
          if (!f.TAG) {
            return Curry._1(f._0, q);
          }
          var s = f._0;
          var g = handleExpr(n, q);
          if (!g.TAG) {
            return {
                    TAG: 0,
                    _0: g._0,
                    [Symbol.for("name")]: "Expect"
                  };
          }
          var t = g._0;
          if (q.TAG === /* App */4) {
            return {
                    TAG: 1,
                    _0: s + (" " + parensIf(true, t)),
                    [Symbol.for("name")]: "Complete"
                  };
          } else {
            return {
                    TAG: 1,
                    _0: s + (" " + t),
                    [Symbol.for("name")]: "Complete"
                  };
          }
      case /* Lam */5 :
          return {
                  TAG: 1,
                  _0: "\\" + (x._0 + (" -> " + toString$5(0, x._1))),
                  [Symbol.for("name")]: "Complete"
                };
      case /* Hole */6 :
          return {
                  TAG: 1,
                  _0: "[?]",
                  [Symbol.for("name")]: "Complete"
                };
      case /* Quant */7 :
          return {
                  TAG: 1,
                  _0: "< " + (toString$5(0, x._0) + (" " + (Caml_splice_call.spliceObjApply(" ", "concat", [Belt_Array.map(x._1, toString$4)]) + (" : " + (toString$5(0, x._2) + (" : " + (toString$5(0, x._3) + " >"))))))),
                  [Symbol.for("name")]: "Complete"
                };
      case /* Subst */8 :
          _x = x._0;
          continue ;
      case /* Unknown */9 :
          return {
                  TAG: 1,
                  _0: "[Uknown expr: " + (JSON.stringify(x._0) + "]"),
                  [Symbol.for("name")]: "Complete"
                };
      
    }
  };
}

function toString$5(n, p) {
  var s = handleExpr(n, p);
  if (s.TAG) {
    return s._0;
  } else {
    return "";
  }
}

var Precedence = {
  classify: classify,
  parensIf: parensIf,
  handleOperator: handleOperator,
  handleExpr: handleExpr,
  toString: toString$5
};

function toString$6(param) {
  return toString$5(0, param);
}

var Expr = {
  locOf: locOf,
  negate: negate,
  disj: disj,
  conj: conj,
  disjunct$prime: disjunct$prime,
  conjunct$prime: conjunct$prime,
  disjunct: disjunct,
  conjunct: conjunct,
  decode: decode$5,
  decodeSubst: decodeSubst,
  encode: encode$5,
  encodeSubst: encodeSubst,
  Precedence: Precedence,
  toString: toString$6
};

function decode$6(json) {
  return Util$Guacamole.Decode.sum(function (tag) {
                switch (tag) {
                  case "Assertion" :
                      return {
                              TAG: 0,
                              _0: (function (param) {
                                  return Json_decode.map((function (param) {
                                                return {
                                                        TAG: 2,
                                                        _0: param[0],
                                                        _1: param[1],
                                                        [Symbol.for("name")]: "Assertion"
                                                      };
                                              }), (function (param) {
                                                return Json_decode.pair(decode$5, decode$1, param);
                                              }), param);
                                }),
                              [Symbol.for("name")]: "Contents"
                            };
                  case "Bound" :
                      return {
                              TAG: 0,
                              _0: (function (param) {
                                  return Json_decode.map((function (param) {
                                                return {
                                                        TAG: 1,
                                                        _0: param[0],
                                                        _1: param[1],
                                                        [Symbol.for("name")]: "Bound"
                                                      };
                                              }), (function (param) {
                                                return Json_decode.pair(decode$5, decode$1, param);
                                              }), param);
                                }),
                              [Symbol.for("name")]: "Contents"
                            };
                  case "Conjunct" :
                      return {
                              TAG: 0,
                              _0: (function (param) {
                                  return Json_decode.map((function (xs) {
                                                return {
                                                        TAG: 6,
                                                        _0: xs,
                                                        [Symbol.for("name")]: "Conjunct"
                                                      };
                                              }), (function (param) {
                                                return Json_decode.array(decode$6, param);
                                              }), param);
                                }),
                              [Symbol.for("name")]: "Contents"
                            };
                  case "Constant" :
                      return {
                              TAG: 0,
                              _0: (function (param) {
                                  return Json_decode.map((function (x) {
                                                return {
                                                        TAG: 0,
                                                        _0: x,
                                                        [Symbol.for("name")]: "Constant"
                                                      };
                                              }), decode$5, param);
                                }),
                              [Symbol.for("name")]: "Contents"
                            };
                  case "Disjunct" :
                      return {
                              TAG: 0,
                              _0: (function (param) {
                                  return Json_decode.map((function (xs) {
                                                return {
                                                        TAG: 7,
                                                        _0: xs,
                                                        [Symbol.for("name")]: "Disjunct"
                                                      };
                                              }), (function (param) {
                                                return Json_decode.array(decode$6, param);
                                              }), param);
                                }),
                              [Symbol.for("name")]: "Contents"
                            };
                  case "GuardIf" :
                      return {
                              TAG: 0,
                              _0: (function (param) {
                                  return Json_decode.map((function (param) {
                                                return {
                                                        TAG: 4,
                                                        _0: param[0],
                                                        _1: param[1],
                                                        [Symbol.for("name")]: "GuardIf"
                                                      };
                                              }), (function (param) {
                                                return Json_decode.pair(decode$5, decode$1, param);
                                              }), param);
                                }),
                              [Symbol.for("name")]: "Contents"
                            };
                  case "GuardLoop" :
                      return {
                              TAG: 0,
                              _0: (function (param) {
                                  return Json_decode.map((function (param) {
                                                return {
                                                        TAG: 5,
                                                        _0: param[0],
                                                        _1: param[1],
                                                        [Symbol.for("name")]: "GuardLoop"
                                                      };
                                              }), (function (param) {
                                                return Json_decode.pair(decode$5, decode$1, param);
                                              }), param);
                                }),
                              [Symbol.for("name")]: "Contents"
                            };
                  case "LoopInvariant" :
                      return {
                              TAG: 0,
                              _0: (function (param) {
                                  return Json_decode.map((function (param) {
                                                return {
                                                        TAG: 3,
                                                        _0: param[0],
                                                        _1: param[1],
                                                        _2: param[2],
                                                        [Symbol.for("name")]: "LoopInvariant"
                                                      };
                                              }), (function (param) {
                                                return Json_decode.tuple3(decode$5, decode$5, decode$1, param);
                                              }), param);
                                }),
                              [Symbol.for("name")]: "Contents"
                            };
                  case "Negate" :
                      return {
                              TAG: 0,
                              _0: (function (param) {
                                  return Json_decode.map((function (x) {
                                                return {
                                                        TAG: 8,
                                                        _0: x,
                                                        [Symbol.for("name")]: "Negate"
                                                      };
                                              }), decode$6, param);
                                }),
                              [Symbol.for("name")]: "Contents"
                            };
                  default:
                    throw {
                          RE_EXN_ID: Json_decode.DecodeError,
                          _1: "[Pred] Unknown constructor: " + tag,
                          Error: new Error()
                        };
                }
              })(json);
}

function encode$6(e) {
  switch (e.TAG | 0) {
    case /* Constant */0 :
        return Json_encode.object_({
                    hd: [
                      "tag",
                      "Constant"
                    ],
                    tl: {
                      hd: [
                        "contents",
                        encode$5(e._0)
                      ],
                      tl: /* [] */0
                    }
                  });
    case /* Bound */1 :
        return Json_encode.object_({
                    hd: [
                      "tag",
                      "Bound"
                    ],
                    tl: {
                      hd: [
                        "contents",
                        Json_encode.pair(encode$5, encode$1, [
                              e._0,
                              e._1
                            ])
                      ],
                      tl: /* [] */0
                    }
                  });
    case /* Assertion */2 :
        return Json_encode.object_({
                    hd: [
                      "tag",
                      "Assertion"
                    ],
                    tl: {
                      hd: [
                        "contents",
                        Json_encode.pair(encode$5, encode$1, [
                              e._0,
                              e._1
                            ])
                      ],
                      tl: /* [] */0
                    }
                  });
    case /* LoopInvariant */3 :
        return Json_encode.object_({
                    hd: [
                      "tag",
                      "LoopInvariant"
                    ],
                    tl: {
                      hd: [
                        "contents",
                        Json_encode.tuple3(encode$5, encode$5, encode$1, [
                              e._0,
                              e._1,
                              e._2
                            ])
                      ],
                      tl: /* [] */0
                    }
                  });
    case /* GuardIf */4 :
        return Json_encode.object_({
                    hd: [
                      "tag",
                      "GuardIf"
                    ],
                    tl: {
                      hd: [
                        "contents",
                        Json_encode.pair(encode$5, encode$1, [
                              e._0,
                              e._1
                            ])
                      ],
                      tl: /* [] */0
                    }
                  });
    case /* GuardLoop */5 :
        return Json_encode.object_({
                    hd: [
                      "tag",
                      "GuardLoop"
                    ],
                    tl: {
                      hd: [
                        "contents",
                        Json_encode.pair(encode$5, encode$1, [
                              e._0,
                              e._1
                            ])
                      ],
                      tl: /* [] */0
                    }
                  });
    case /* Conjunct */6 :
        return Json_encode.object_({
                    hd: [
                      "tag",
                      "Conjunct"
                    ],
                    tl: {
                      hd: [
                        "contents",
                        Json_encode.array(encode$6, e._0)
                      ],
                      tl: /* [] */0
                    }
                  });
    case /* Disjunct */7 :
        return Json_encode.object_({
                    hd: [
                      "tag",
                      "Disjunct"
                    ],
                    tl: {
                      hd: [
                        "contents",
                        Json_encode.array(encode$6, e._0)
                      ],
                      tl: /* [] */0
                    }
                  });
    case /* Negate */8 :
        return Json_encode.object_({
                    hd: [
                      "tag",
                      "Negate"
                    ],
                    tl: {
                      hd: [
                        "contents",
                        encode$6(e._0)
                      ],
                      tl: /* [] */0
                    }
                  });
    
  }
}

function toExpr(e) {
  switch (e.TAG | 0) {
    case /* Conjunct */6 :
        var xs = Belt_Array.map(e._0, toExpr);
        return conjunct$prime(Belt_List.fromArray(xs));
    case /* Disjunct */7 :
        var xs$1 = Belt_Array.map(e._0, toExpr);
        return disjunct$prime(Belt_List.fromArray(xs$1));
    case /* Negate */8 :
        return negate(toExpr(e._0));
    default:
      return e._0;
  }
}

function toString$7(xs) {
  return toString$5(0, toExpr(xs));
}

var Pred = {
  decode: decode$6,
  encode: encode$6,
  toExpr: toExpr,
  toString: toString$7
};

function toString$8(param) {
  if (param) {
    return "Bool";
  } else {
    return "Int";
  }
}

function decode$7(param) {
  return Json_decode.map((function (tag) {
                switch (tag) {
                  case "TBool" :
                      return /* Bool */1;
                  case "TInt" :
                      return /* Int */0;
                  default:
                    throw {
                          RE_EXN_ID: Json_decode.DecodeError,
                          _1: "Unknown constructor: " + tag,
                          Error: new Error()
                        };
                }
              }), Json_decode.string, param);
}

var Base = {
  toString: toString$8,
  decode: decode$7
};

function toString$9(b) {
  switch (b.TAG | 0) {
    case /* Base */0 :
        if (b._0) {
          return "Bool";
        } else {
          return "Int";
        }
    case /* Array */1 :
        return "Array " + toString$9(b._0);
    case /* Func */2 :
        return toString$9(b._0) + (" -> " + toString$9(b._1));
    case /* Var */3 :
        return "Var " + String(b._0);
    
  }
}

function decode$8(json) {
  return Util$Guacamole.Decode.sum(function (tag) {
                switch (tag) {
                  case "TArray" :
                      return {
                              TAG: 0,
                              _0: (function (param) {
                                  return Json_decode.map((function (x) {
                                                return {
                                                        TAG: 1,
                                                        _0: x,
                                                        [Symbol.for("name")]: "Array"
                                                      };
                                              }), decode$8, param);
                                }),
                              [Symbol.for("name")]: "Contents"
                            };
                  case "TBase" :
                      return {
                              TAG: 0,
                              _0: (function (param) {
                                  return Json_decode.map((function (x) {
                                                return {
                                                        TAG: 0,
                                                        _0: x,
                                                        [Symbol.for("name")]: "Base"
                                                      };
                                              }), decode$7, param);
                                }),
                              [Symbol.for("name")]: "Contents"
                            };
                  case "TFun" :
                      return {
                              TAG: 0,
                              _0: (function (param) {
                                  return Json_decode.map((function (param) {
                                                return {
                                                        TAG: 2,
                                                        _0: param[0],
                                                        _1: param[1],
                                                        [Symbol.for("name")]: "Func"
                                                      };
                                              }), (function (param) {
                                                return Json_decode.pair(decode$8, decode$8, param);
                                              }), param);
                                }),
                              [Symbol.for("name")]: "Contents"
                            };
                  case "TVar" :
                      return {
                              TAG: 0,
                              _0: (function (param) {
                                  return Json_decode.map((function (x) {
                                                return {
                                                        TAG: 3,
                                                        _0: x,
                                                        [Symbol.for("name")]: "Var"
                                                      };
                                              }), Json_decode.$$int, param);
                                }),
                              [Symbol.for("name")]: "Contents"
                            };
                  default:
                    throw {
                          RE_EXN_ID: Json_decode.DecodeError,
                          _1: "Unknown constructor: " + tag,
                          Error: new Error()
                        };
                }
              })(json);
}

var Type = {
  Base: Base,
  toString: toString$9,
  decode: decode$8
};

var Syntax = {
  VarArg: VarArg,
  Lit: Lit,
  Op: Op,
  Name: Name,
  Expr: Expr,
  Pred: Pred,
  Type: Type
};

exports.Pos = Pos;
exports.Loc = Loc;
exports.Syntax = Syntax;
/* decode Not a pure module */
